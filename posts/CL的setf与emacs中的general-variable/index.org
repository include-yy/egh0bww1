#+SETUPFILE: ../../setup.org
#+TITLE: CL 的 setf 与 emacs 中的 general-variable
#+TITLE:
#+DATE: [2022-02-21 Mon 9:08]
#+TAGS: emacs

由标题可知，本文的内容与 =setf= 这个宏有关，这里我假设你已经知道了它最基本的用法。本文的主要内容分为两大部分，首先我会展示 =setf= 的使用方法，以及介绍 CL 中 =setf= 的扩展方法。随后我会介绍 emacs 中的 =setf= 机制。在后一部分我会简单分析 emacs 中的实现，它位于 gv.el 文件中，核心代码行数在 200 行左右。

在文中我会穿插一些 CL 和 emacs-lisp 中 setf 的用例。它们大多来自 /On lisp/ 。

本文使用的代码环境如下：

- emacs 27.2 x86_64 on windows
- ECL 21.2.1 built with msvc

* 什么是 setf

学过一点 Lisp（特指 CL）的人都知道，有个叫 =setq= 的东西，使用它可以方便地设置符号的 =symbol-value= 值，而不必要使用蹩脚的 =set= 。在 CL 中它是个 =special form= ，在 emacs lisp 中它是个 =#<subr>= 。下面的 =setq= 表达式和 =set= 表达式的效果相同：

#+BEGIN_SRC lisp
(setq a 1) => 1
(set 'a 1) => 1
;; emacs-lisp
(symbol-function 'setq)
=> #<subr setq>
;; common-lisp
(symbol-function 'setq)
=> SPECIAL
#+END_SRC

=setf= 可以理解为 =setq= 一般化后的版本。除了符号外，它可以接受一个表达式，然后对表达式想要取值的“位置”进行赋值操作。换句话说，它可以根据 =getter= 表达式来得出对应的 =setter= 表达式，也就是获得 =getter= 对应的逆操作。举例来说的话就是这样：

#+BEGIN_SRC lisp
(setq a '(1 2 3))
(progn (setf (car a) 2) a) => (2 2 3)
(progn (setf (car (cdr a)) 3) a) => (2 3 3)
(progn (setf (car (cdr (cdr a))) 4) a) => (2 3 4)
#+END_SRC

=setf= 中的“位置”被称为 /generalized variable/ ，非要翻译一下的话就是“一般化变量”。不加说明的话，下面我们使用 =gv= 来作为它的缩写。除了上面例子中使用的表操作， =setf= 还支持向量，哈希表等等。 /On Lisp/ 的 176 页中这样写道：

#+BEGIN_QUOTE
All the most frequently used Common Lisp access functions have predefined inversions, including car, cdr, nth, aref, get, gethash, and the access functions created by defstruct.
#+END_QUOTE

容易看出 =setq= 中的 "q" 对应的是 =quote= ，用了它我们就不用写 ='= 了。那么 =setf= 中的 字母 "f" 对应的是哪个呢？不论是 common-lisp 还是 elisp 都使用 “PLACE” 来称呼 =setf= 中的赋值位置，那合理猜想一下 “f” 对应的应该是 “form”，也就是“形式”。不过也有认为它对应的应该是 “function” 的说法。

* CL 中的 setf 与 gv

在这一节中我会介绍在 CL 中扩展 =setf= 的方法。 =setf= 默认支持一些常见的 =getter= ，我们可以使用 CL 提供的一些机制来对其进行扩展。对我这 CL 新手来说， /On Lisp/ 上的一些例子看的我觉得有点匪夷所思。

对于简单情况和复杂情况，CL 提供了不同的宏来供用户使用。 =define-modify-macro= 可以用来定义类似于 =incf= 和 =decf= 的宏，它的原型如下：

#+BEGIN_SRC lisp
(define-modify-macro symbol lambda-list function-name [doc])
#+END_SRC

其中， =symbol= 是想要定义的宏的名字， =lambda-list= 是参数表，表示除 gv 外的其他参数。 =lambda-list= 是具体的赋值操作函数，它的第一个参数就是 gv，它的返回值将赋给 gv 对应的位置。举例来说的话，假如我们想要对一个 gv 进行取反操作，我们可以这样：

#+BEGIN_SRC lisp
(define-modify-macro yy-nnot () not)
(setq a '(1 2 3))
(yy-nnot (car a))
a => (NIL 2 3)
#+END_SRC

下面是一些带参数的例子：

#+BEGIN_SRC lisp
(define-modify-macro yy-nmul (n) (lambda (place n) (* place n)))
(setq a 2)
(yy-nmul a 3) => 6

(define-modify-macro yy-nconc (&rest ls) (lambda (place &rest ls) (apply #'nconc place ls)))
(setq a '(1 2 3))
(yy-nconc a '(4) '(5))
a => (1 2 3 4 5)
#+END_SRC

简单来说，使用 =define-modify-macro= 可以简化一些 =setf= 的操作，就比如使用 =incf= 我们就可以写 =(incf a 20)= 而不用写 =(setf a (+ a 20))= 了。emacs-lisp 在 cl.el 文件中也实现了这个宏，它在内部使用了 =cl-callf= 来完成 gv 的求值与赋值。

=define-modify-macro= 只能用来编写一些简单的宏，想要实现更加复杂的功能，我们需要使用 =define-setf-expander= （以下简称 =dse= ）和 =get-setf-expansion= （以下简称 =gse= ）来定义和获取 gv 的一些信息。它们的原型如下：

#+BEGIN_SRC lisp
-----------------------------------------------------------------------------
DEFINE-SETF-EXPANDER                                                  [Macro]
Syntax: (define-setf-expander symbol defmacro-lambda-list {decl | doc}*
          {form}*)
Defines the SETF-method for generalized-variables (SYMBOL ...).
When a form (setf (SYMBOL arg1 ... argn) value-form) is evaluated, the FORMs
given in the DEFINE-SETF-EXPANDER are evaluated in order with the parameters in
DEFMACRO-LAMBDA-LIST bound to ARG1 ... ARGn.  The last FORM must return five
values
        (var1 ... vark)
        (form1 ... formk)
        (value-var)
        storing-form
        access-form
in order.  These values are collectively called the five gangs of the
generalized variable (SYMBOL arg1 ... argn).  The whole SETF form is then
expanded into
        (let* ((var1 from1) ... (vark formk)
               (value-var value-form))
          storing-form)
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (DOCUMENTATION 'SYMBOL 'SETF).
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
GET-SETF-EXPANSION                                                 [Function]
Args: (form)
Returns the 'five gangs' (see DEFINE-SETF-EXPANDER) for PLACE as five values.
Does not check if the third gang is a single-element list.
-----------------------------------------------------------------------------
#+END_SRC

简单起见，咱们还是先从 =gse= 开始说起。由上述文档可知， =gse= 会返回一个“五元组”（five gangs），它们分别是：

- =(var1 ... vark)= ，它是一个符号表，各符号 *对应* 于出现在 =(symbol arg1 ... argn)= 中的 =arg1 ... argn=
- =(form1 ... formn)= ，它是 =(symbol arg1 ... argn)= 中的各 =arg1 ... argn= 表达式
- =(value-var)= 最终用于赋值操作的符号
- =storing-form= ，执行赋值操作的表达式
- =access-form= ，用于访问 =form= 对应“位置”的表达式

这里我们用个简单的例子来说明各值的具体作用：

#+BEGIN_SRC lisp
(get-setf-expansion '(aref x (incf b)))
(#:G113 #:G114)
(X (INCF B))
(#:G115)
(SI:ASET #:G113 #:G114 #:G115)
(AREF #:G113 #:G114)
#+END_SRC

上面对应的 =from= 是 =(aref x (incf b))= ，可见表中有两个表达式，所以五元组的第一元素对应的是长度为 2 的符号表。第二元素就是 =form= 中各参数表达式，第三元素是出现在 =storing-form= 中的符号，第四元素是赋值操作表达式，第五元素是值访问表达式。

=setf= 在遇到定义好的扩展时会将其展开成默认形式。也就是上面文档中的样子。这里我就不重复了。

下面我们不使用 =setf= ，而是自己编写一个宏来作为对五元组处理的例子：

#+BEGIN_SRC lisp
(defmacro yy-arefset (form val)
  (assert (eq (car form) 'aref))
  (multiple-value-bind (vs fs g sop aop)
      (get-setf-expansion form)
    `(let (,@(mapcar #'list vs fs)
	   (,(car g) ,val))
       ,sop)))

(setq a #(1 2 3))
(yy-arefset (aref a 1) 1)
a => #(1 1 3)
#+END_SRC

如果我们想使用 =setf= 而不是像上面一样自己定义宏，那么可以使用 =define-setf-expander= 来定义新的五元组生成器：

#+BEGIN_SRC lisp
(define-setf-expander yy-arefset-g (place index)
  (let ((var (gensym))
	(pos (gensym))
	(setvar (gensym)))
    (values
     `(,var ,pos)
     `(,place ,index)
     `(,setvar)
     `(setf (aref ,var ,pos) ,setvar)
     `(aref ,var ,pos))))

(get-setf-expansion '(yy-arefset-g a (+ 1 2))) =>
(#:G152 #:G153)
(A (+ 1 2))
(#:G154)
(SETF (AREF #:G152 #:G153) #:G154)
(AREF #:G152 #:G153)

(setq a #(1 2 3))
(setf (yy-arefset-g a 0) 2) => #(2 2 3)
(macroexpand '(setf (yy-arefset-g a 0) 2)) =>
(LET* ((#:G167 A) (#:G168 0))
  (MULTIPLE-VALUE-BIND (#:G169) 2 (SETF (AREF #:G167 #:G168) #:G169)))
#+END_SRC

CL 还提供了一种轻松定义 =getter= 对应的 =setter= 的方法，那就是使用 =defsetf= 。它的原型如下：

#+BEGIN_SRC lisp
-----------------------------------------------------------------------------
DEFSETF                                                               [Macro]
Syntax: (defsetf symbol update-fun [doc])
        or
        (defsetf symbol lambda-list (store-var*) {decl | doc}* {form}*)
Defines an expansion
(setf (SYMBOL arg1 ... argn) value)
=> (UPDATE-FUN arg1 ... argn value)
or
(let* ((temp ARG)*)
  (multiple-value-bind (temp-s*)
      values-form
    rest)
  where REST is the value of the last FORM with parameters in
  LAMBDA-LIST bound to the symbols TEMP* and with STORE-VAR* bound to
  the symbols TEMP-S*.  The doc-string DOC, if supplied, is saved as a
  SETF doc and can be retrieved by (documentation 'SYMBOL 'setf).
-----------------------------------------------------------------------------
#+END_SRC

它的用法分为两种，一种简单的和一种复杂的，下面先演示简单的用法：

#+BEGIN_SRC lisp
(defun yy-caar (x) (car (car x)))
(defun yy-caar-set (x v) (setf (caar x) v))
(defsetf yy-caar yy-caar-set)

(setq a '((1) 2 3))
(setf (yy-caar a) 2)
a => ((2) 2 3)
(macroexpand '(setf (yy-caar a) 1)) =>
(YY-CAAR-SET A 1)
#+END_SRC

相比于简单用法，复杂用法使用 =store-var= 与 =setf= 剩余参数绑定，处理起来更加灵活：

#+BEGIN_SRC lisp
(defun yy-cadr (x) (second x))
(defsetf yy-cadr (lst) (new-val)
  `(progn (setf (cadr ,lst) ,new-val)))

(setq a '(1 2 3))
(setf (yy-cadr a) 3)
a => (1 3 3)
#+END_SRC

除了说使用 =defsetf= ，我们还可以使用 =(defun (setf fun) ...)= 的形式来定义 =setter= ，例如：

#+BEGIN_SRC lisp
(defun yy-car (x) (car x))
(defun (setf yy-car) (val ls) (rplaca ls val) val)
(setq a '(1 3 3))
(setf (yy-car a) 2) => (2 3 3)
#+END_SRC

注意上面的参数表中，值放在第一位。

以上，我们就完成了对 CL 中的 setf 和 gv 的简单介绍。

* 简单实现 cl 中的 setf 和 gv 机制

通过上一节的介绍，我们已经基本清楚了 CL 提供的 setf 和 gv 设施。它们是：

- =define-modify-macro= ，提供简单的 =setf= 扩展
- =defsetf= ，方便地定义 =getter= 对应的 =setter=
- =dse= 和 =gse= ，复杂且强大的 gv 扩展工具

* elisp 中 gv 机制

elisp 中提供了 =define-modify-macro= 和 =defsetf= ，但是只提供了 =dse= 而没有 =gse= 。在 cl.el 中有这样一段注释：

#+BEGIN_SRC emacs-lisp
;; FIXME: CL used to provide get-setf-method, which was used by some
;; setf-expanders, but now that we use gv.el, it is a lot more difficult
;; and in general impossible to provide get-setf-method.  Hopefully, it
;; won't be needed.  If needed, we'll have to do something nasty along the
;; lines of
;; (defun get-setf-method (place &optional env)
;;   (let* ((witness (list 'cl-gsm))
;;          (expansion (gv-letplace (getter setter) place
;;                      `(,witness ,getter ,(funcall setter witness)))))
;;     ...find "let prefix" of expansion, extract getter and setter from
;;     ...the rest, and build the 5-tuple))
#+END_SRC

由注释可知，elisp 现在提供了全新的 gv 机制，它的实现位于 gv.el 中。因此本节的内容主要是对 gv.el 功能的介绍。由于要讲清楚它的功能必须要说明它的原理，这一节我会依照 gv.el 中的实现给出一个更简单的实现以方便理解。在下一节中我们会完整地介绍 gv.el 的全部功能。

gv.el 的版权时间是从 2012 年开始的，它的作者是 Stefan Monnier。在文件开头的注释简要介绍了实现原理，这里我结合自己理解简述一下。相比于 CL 中的 =define-setf-expander= ，它使用了不同的方法重新实现了 setf 机制。

=dse= 定义了返回五元组 =(vars values stores getter setterr)= 的展开器。与之不同的是，这里使用了基于高阶函数的方法。展开器会返回一个函数而不是五元组。该函数接受一个 =do= 函数并完成相应工作。 =do= 函数接受两个参数，第一参数是获取 =PLACE= 值的表达式，第二参数是一个函数，它接受一个值表达式，并返回将 =PLACE= 设置为该值的代码（也就是对应的 sexp）。

怎么理解这个高阶函数的使用方法呢？我的理解是：首先使用展开器来获取 gv 的 =getter= 和 =setter= 表达式，并将它们以代码的形式存放到展开器返回的高阶函数中。类似于这个样子：

#+BEGIN_SRC
(setq a (<generate-function> <something>)
a =>
(lambda (do)
  (funcall do <getter-form> <setter-function>))
#+END_SRC

这样一来，我们把动作写进 =do= 函数里面，就可以执行我们想要的操作了。如果想要获取值就可以返回第一参数的值，并忽略掉 =do= 的第二参数。如果想要进行赋值操作，就可以将想要的值放入 =do= 函数中，并在函数中调用 =setter= 函数获取赋值代码。这两个操作的代码如下：

#+BEGIN_SRC emacs-lisp
;; 获取值
(funcall a (lambda (g s) g))
;; 设置值
(defmacro (set-a a v-exp)
    (funcall a (lambda (g s)
		 (funcall s v-exp))))
(set-a a <something>)
#+END_SRC

这大概就是 gv.el 的基本原理。实际上不用展开器我们也可以定义出可用的高阶函数，下面我们来实现一下最基本的配套函数，也就是 =car= 和对应的 =setcar= 。

#+BEGIN_SRC emacs-lisp
(defvar yy-high-order-store-table (make-hash-table))
;;为表生成对应的高阶函数
(defun yy-genit (symb)
  `(lambda (doit)
     (funcall doit (list 'car ,symb)
	      (lambda (v) (list 'setcar ,symb v)))))

(puthash 'yycar 'yy-genit yy-high-order-store-table)

(defun yycar (x) (car x))

(defmacro yy-setf (place val)
  (if (atom place)
      `(setq ,place ,val)
    (funcall (funcall (gethash (car place) yy-high-order-store-table)
		      `',(cadr place))
	     (lambda (g s)
	       (funcall s val)))))

(setq a '(1 2 3))
(yycar a) => 1
(yy-setf (yycar a) 2) => 2
a => (2 2 3)
#+END_SRC

上面的实现是个相当简陋的实现，使用哈希表来存储高阶函数生成函数，只支持单参数的 =getter= 函数，没有处理宏展开以及 function indirection，不支持嵌套的 =PLCAE= ，不过也足以说明原理了。

* elisp 的 gv.el 实现

上一小节实现的 =yy-setf= 太过简陋，在这一小节中我们学习一下 gv.el 中的实现。

对应于 CL 中 =dse= 的是名为 =gv-define-expander= 的宏，它接受一个符号和一个高阶函数，并将高阶函数放入符号的 plist 中，我上面实现的是放入哈希表中。 =gv-define-expander= 只有几行，高阶函数需要自行编写：

#+BEGIN_SRC emacs-lisp
(defmacro gv-define-expander (name handler)
  (declare (indent 1) (debug (sexp form)))
  `(function-put ',name 'gv-expander ,handler))
#+END_SRC

接下来介绍一下用于生成高阶函数的 =gv-define-setter= 和 =gv--defsetter= 。 =gv-define-setter= 在内部调用 =gv-define-expander= 将高阶函数与符号绑定。

* 参考资料

- /On lisp/
