#+SETUPFILE: ../../setup.org
#+TITLE: emacs 的 macro
#+TITLE: @@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzkwMzY3NjEy.jpg" alt="load failed"></div>@@
#+DATE: [2021-08-21 Sat 09:58]
#+TAGS: emacs

在某篇文章中介绍 debug 相关的内容后，我本应该直接开始学习并记录测试相关的知识，但在 emacs-china 上读到这个帖子[fn::https://emacs-china.org/t/emacs-ci/12103]emacsemacs 的 byte compile。macro 和字节编译也是有关系的，所以在这篇文章中我们还是先谈谈 macro 吧。

宏可以用来定义新的控制结构和其他的语言特性。宏定义起来很像函数，但相比于函数是为了求值，宏是为了得到另一个 Lisp 表达式，它在随后才被用来求值。得到新表达式的过程被称为宏的 *展开* 。

光是宏本身的话其实没什么好谈的，不就是宏的定义与展开吗？但是弄清楚了这两点并不能让你迅速熟练宏的使用，毕竟 /the best way to learn write macro is to write macro/ 。在本文中，除了向你介绍宏的基本使用方法外，我还会介绍一些好用的工具宏，以及一些简单的例子，希望对你有所帮助。

* 宏与函数的区别

在 emacs 中，我们使用 =defmacro= 来定义宏，它的语法是：

#+BEGIN_SRC emacs-lisp
(defmacro name args [doc] [declare] body)
#+END_SRC

除了说没有 =interactive= 部分外，其余部分和 =defun= 几乎一模一样。elisp 的宏对象是一张表，它的 car 部分是符号 =macro= ，cdr 部分是一个函数。就像这样：

#+BEGIN_SRC emacs-lisp
(defmacro yymac (a) (list 'list a))
(symbol-function 'yymac)
=> (macro lambda (a) (list 'list a))

(yymac 'hello) => (hello)
#+END_SRC

既然宏的内部也是函数，那么它和函数的区别在哪里呢？这主要体现在两个方面。

- 其一，宏的参数在被传递给宏体求值前不会像函数那样被求值，它会作为表达式而不是值参与宏展开，就比如上面的 =yymac= ，假如使用 value 为 1 的变量 =a= 作为参数调用，得到的 *展开结果* 是 =(list a)= 而不是 =(list 1)= 。
- 其二，宏体中的函数返回值应该是另一个 Lisp 表达式，Lisp 解释器会对这个表达式求值，来得到宏调用的结果。

简而言之，宏对参数做的不是求值而是替换。函数调用的返回值由对函数体求值而得到，宏调用的返回值则是由对宏展开后的表达式求值得到。

除了上面的那种使用 =list= 来构建表达式的方法，我们也可以使用 =backquote= （即 =`= ）来方便地构建 Lisp 表达式。它的方便体现在不用使用过多的 list 函数，以及使用 =,= 和 =,@= 来进行插值。

=`= 的行为和 ='= 几乎一致，除了说某些部分可以求值外。在以下例子中可以体现出这一点：

#+BEGIN_SRC emacs-lisp
  `(1 2 3) => (1 2 3)
  `(1 2 ,(+ 1 2)) => (1 2 3)
  '(1 2 (+ 1 2)) => (1 2 (+ 1 2))

  `(1 2 ,@(list 1 2 3)) => (1 2 1 2 3)
#+END_SRC

在 Scheme 中它也被叫做 =quasiquote= ，意思是准引用。

在 =backquote= body 里面， =,= 和 =,@= 的作用就是对表达式求值，然后将得到的值填充到其所在位置。上面的 defmacro 例子可以写成这样：

#+BEGIN_SRC emacs-lisp
    (defmacro yymac-2 (a) `(list ,a))
    (yymac-2 1) => (1)
    (macroexpand '(yymac-2 abc)) => (list abc)
    (macroexpand '(yymac-2 (1 2 3))) => (list (1 2 3)) ;bad form
    (macroexpand '(yymac-2 '(1 2 3))) => (list '(1 2 3))
#+END_SRC

我拿使用 =`= 和不使用 =`= 的宏对比一下，下面使用 =`= 的代码可以少写 4 个 =list= ：

#+BEGIN_SRC emacs-lisp
  (defmacro mac-print (ls)
     (let ((a ls))
     `(progn
	(print ,(car a))
	(print ,(cadr a))
	(print ,(caddr a)))))

  (defmacro mac-print-2 (ls)
     (let ((a ls))
	(list 'progn
	      (list 'print (car a))
	      (list 'print (cadr a))
	      (list 'print (caddr a)))))
  (macroexpand '(mac-print (1 2 3))) => (progn (print 1) (print 2) (print 3))
  (macroexpand '(mac-print-2 (1 2 3))) => (progn (print 1) (print 2) (print 3))
#+END_SRC

由于 macro 接收参数时不求值的特性，在上面的 =mac-print= 宏展开中，将 表表达式 =(1 2 3)= 传递给宏后，它被成功绑定到了 =ls= 上，然后绑定到 let 变量 =a= 上（使用 let 仅仅是为了说明宏参数的值仅仅是个普通的表达式罢了），而没有出现类似 =Debugger entered--Lisp error: (invalid-function 1)= 的错误。

对于 Lisp 宏来说，它接受的参数类型只有两种，即 /atom/ 和 /list/ （是的，凡不是 list 的都算作 atom，比如 string vector 之类的）。下面的例子中，我对宏参数使用 =predicate= 来判断其类型：

#+BEGIN_SRC emacs-lisp
  (defmacro mac-val (x)
    (if (and (atom x) (symbolp x))
	 `(progn (print ,x)
		 (print (+ ,x 1)))
      nil))
  (macroexpand '(mac-val yy)) => (progn (print yy) (print (+ yy 1)))
  (macroexpand '(mac-val 1)) => nil
  (macroexpand '(mac-val (quote yy))) => nil ;(quote yy) is a list
#+END_SRC

对于不同类型的宏参数，使用针对其类型的函数对其进行操作是可行的，比如我上面对 list 用到的 =car= ， =cadr= 和 =caddr= 。不过对于宽泛的 atom（不明确其具体类型）来说，可用的函数好像就 =atom= 一个，它用来判断某个对象是不是 atom。

需要注意的一点是，对于宏参数，最好不要使用带副作用的操作，这样可能会引发意想不到的后果。

* 与宏相关的一些函数和宏

这里我只介绍四个函数，这也是在 elisp manual 上列出的四个函数。

- =macrop= 用于判断它的参数是否为 macro，若是则返回 t，否则返回 nil
- =macroexpand= 接受一个 =form= 和可选的 =environment= ，如果 =form= 是宏调用的话，它会将宏调用展开，如果展开结果还是宏调用则继续展开，直到结果不是宏调用为止。最后的结果就作为函数的返回值。需要注意的是，它不负责 =form= 子表达式中的宏调用
- =macroexpand-all= 的参数表与 =macroexpand= 相同，但它除了处理 =form= 的宏调用外还会处理子表达式的宏调用。也就是说它会将整个宏调用完全展开，里面不会剩下任何的宏调用
- =macroexpand-1= 的参数表和上面两个函数一致，它的行为与 =macroexpand= 相似，但是它的展开只进行一次。如果一次展开结果还是宏调用的话，它就直接返回结果而不进行进一步展开

以下例子可以说明 =macroexpand= 系列函数之间的区别：

#+BEGIN_SRC emacs-lisp
(defmacro inc (var)
  (list 'setq var (list '1+ var)))
(defmacro inc2 (v1 v2)
  (list 'progn (list 'inc v1) (list 'inc v2)))

(macroexpand '(inc2 a b)) => (progn (inc a) (inc b))
(macroexpand-1 '(inc2 a b)) => (progn (inc a) (inc b))
(macroexpand-all '(inc2 a b)) => (progn (setq a (1+ a)) (setq b (1+ b)))

(defmacro yy-two (mac-name val)
  (list mac-name val))

(macroexpand '(yy-two inc a)) => (setq a (1+ a))
(macroexpand-1 '(yy-two inc a)) => (inc a)
#+END_SRC

关于 =environment= 参数，文档上是这样说的：

 #+BEGIN_QUOTE
/If environment is provided, it specifies an alist of macro definitions that shadow the currently defined macros. Byte compilation uses this feature./
 #+END_QUOTE

具体的用法可以参考这个例子：

#+BEGIN_SRC emacs-lisp
(defmacro inctri (var)
  (list 'setq var (list '+ var 3)))

(macroexpand-all '(inc2 a b) '((inc . (lambda (v) (list 'setq v (list '+ v 3))))))
=> (progn (setq a (+ a 3)) (setq b (+ b 3)))
(macroexpand-all '(inc2 a b) `((inc . ,(cdr (symbol-function 'inctri)))))
=> (progn (setq a (+ a 3)) (setq b (+ b 3)))
#+END_SRC

* 宏的缩进

在阅读 emacs 的 elisp 源代码时，你可能会看到某些宏里面还有一条类似这样的声明： =(declare (indent 1))= ，这是在声明宏调用的缩进方式。老实说，文档上关于 declare indent 的部分写的有点晦涩，我尽量多用些例子说明它的用法。

注意，这里说的缩进是指当你调用函数或宏的时候参数的缩进方式，不是函数或宏定义的缩进方式。至于为什么要把 =indent= 放到 =macro= 这一章来讲，应该是 =indent= 在宏中使用较多的缘故。

indent 接受的参数有以下几种形式：

- =nil= 表示使用标准的缩进模式， =(indent nil)= 相当于不指定 indent

- =defun= 使用 *定义* 结构的缩进，即将第二行作为 =body= 的开始

- 整数 =number= ，它让前 =number= 个参数变成 distinguished arguments（这里译为分界参数），剩余的参数被当成表达式的 body 部分。表达式中的行会根据它的第一个参数是否为分界参数来决定它的缩进方式。如果参数不是分界参数，那么该行会使用 =lisp-body-indent= 加上当前所在表达式缩进来作为缩进列数；如果参数是分界参数且是第一个或第二个，那么它会进行两次缩进，即当前缩进加上两个 =lisp-body-indent= ；对于非第一第二的分界参数，会使用标准模式缩进，即对齐上一行的首参数

- 一个符号 =symbol= ，它是一个函数名，函数被用来计算行的缩进。函数接受 =pos= 和 =state= 两个参数， =pos= 是行的缩进开始位置， =state= 是 =parse-partial-sexp= 在解析完当前行后的返回值。函数的返回值可以是一个整数或一个包含整数的表。如果返回整数，当前行的下面的同层行会与它对齐；如果返回表，下面的行可以使用不同的缩进

=nil= 是最好理解的，就是不对 indent 进行设置，这种情况下的缩进是这样的：下一行的参数与上一行的首个参数保持缩进对齐：

#+BEGIN_SRC emacs-lisp
(defun ind_nil (x y z a)
  (list x y z a))

(ind_nil
 1
 2
 3
 4)

(ind_nil 1
         2
         3
         4)

(ind_nil 1 2
	 3
         4)
#+END_SRC

=defun= 就是类似 defun 的缩进，即将第二行当作 body，缩进一个 =lisp-body-indent= ，这与 nil 是不同的：

#+BEGIN_SRC emacs-lisp
(defun ind_defun (a b c d)
  (declare (indent defun))
  (list a b c d))

(ind_defun 1
  2
  3
  4)

(ind_defun 1 2
  3 4)
#+END_SRC

指定 =number= 作为 indent 在宏里面好像是一种很常见的行为，它用来说明哪几个参数是需要特殊缩进的，就像这样：

#+BEGIN_SRC emacs-lisp
(defun ind_num (a b c d e)
  (declare (indent 3))
  (list a b c d e))

(ind_num
    1
    2
    3
  4
  5)

(ind_num 1
    2
    3
  4
  5)

(ind_num 1 2
	 3
  4
  5)
#+END_SRC

对于 =symbol= ，文档居然连个例子也没给。那只能自己摸索了，首先使用常函数作为缩进函数，然后 trace 它来观察它的行为：

#+BEGIN_SRC emacs-lisp
(defun ind_ind (pos state) 1)
(defun ind_syn (a b c d)
  (declare (indent ind_ind))
  (list a b c d))
(trace-function-background 'ind_ind)

;; put these lines at the beginning of an empty buffer
(ind_syn
 1
 2
 3
 4)
 #+END_SRC

我们在参数 =1, 2, 3, 4= 所在的行分别按下 tab，观察一下 buffer *trace-output* 中的输出：

#+BEGIN_SRC
======================================================================
1 -> (ind_ind 10 (1 1 2 nil nil nil 0 nil nil (1) nil))
1 <- ind_ind: 1
======================================================================
1 -> (ind_ind 13 (1 1 11 nil nil nil 0 nil nil (1) nil))
1 <- ind_ind: 1
======================================================================
1 -> (ind_ind 16 (1 1 14 nil nil nil 0 nil nil (1) nil))
1 <- ind_ind: 1
======================================================================
1 -> (ind_ind 19 (1 1 17 nil nil nil 0 nil nil (1) nil))
1 <- ind_ind: 1
#+END_SRC

可以看到，第一个参数 pos 确实是行首的 point ，但是第二参数是一张复杂的表，需要参考文档来了解表中各个元素的含义。使用 =C-h f parse-partial-sexp= 可以进行阅读，以下是返回值的说明：

- 0. 括号的深度
- 1. 最内层的包含列表的起始字符位置
- 2. 最后一个完整 sexp 的起始位置
- 3. 当在字符串内时非空
- 4. 在注释内时非空
- 5. 如果跟着 ='= 则为非空
- 6. 本次扫描遇到的最小括号深度
- 7. 注释的样式，如果有的话
- 8. 字符串或注释的起始字符位置，如果为 nil 则说明不存在
- 9. 当前最外面的开括号的位置
- 10. When the last position scanned holds the first character of a (potential) two character construct, the syntax of that position, otherwise nil.  That construct can be a two character comment delimiter or an Escaped or Char-quoted character.（翻译不能）

根据 =parse-patrial-sexp= 返回值的含义，我们可以编写出一个使 body 的奇数行缩进四格，偶数行缩进两格的函数：

#+BEGIN_SRC emacs-lisp
(defun ind_ind2 (pos state)
  (let ((current-line-delta (- (line-number-at-pos pos)
				(line-number-at-pos (nth 1 state)))))
    (if (zerop (% current-line-delta 2)) '(2) '(4))))

(defun ind_syn2 (a b c d)
  (declare (indent ind_ind2))
  (list a b c d))

;; we get this
(ind_syn2
    1
  2
    3
  4)

 #+END_SRC

我们甚至可以写出每增一行缩进加一的函数

#+BEGIN_SRC emacs-lisp
(defun ind_ind3 (pos state)
  (let ((current-line-delta (- (line-number-at-pos pos)
				(line-number-at-pos (nth 1 state)))))
    (list current-line-delta)))


(defun ind_syn3 (a b c d)
  (declare (indent ind_ind3))
  (list a b c d))

(ind_syn3
 1
  2
   3
    4)
 #+END_SRC

上面的缩进函数的返回值我都使用了带括号的形式，如果不带括号的话那么下面的参数必须与上面的参数保持相同缩进。 =parse-partial-sexp= 的返回值我只用了一个，使用其他的值也许可以写出更加有趣的缩进函数，这里我就不进一步尝试了。

* 宏与 lexical-binding

前面我也说到过，宏的结构就是 car 是 符号 =macro= ，cdr 是函数的序对。在 lexical-binding 为 nil 和 非 nil 的情况下对 macro 中的函数是有影响的：

#+BEGIN_SRC emacs-lisp
(setq lexical-binding nil)
(defmacro foo-1 (x)
  (list 'list x))
(symbol-function 'foo-1) => (macro lambda (x) (list 'list x))

(setq lexical-binding t)
(defmacro foo-2 (x)
  (list 'list x))
(symbol-function 'foo-2) => (macro closure (t) (x) (list 'list x))
 #+END_SRC

可以看到，此时 macro 的 cdr 是一个闭包而不是单纯的 lambda 函数。此后即便 lexical-binding 设置为 nil，调用这个宏也会按照词法作用域规则求值。

* manual 中提到的注意事项

这一小节主要是 manual 上关于宏的需要注意的地方，我把它们综合了一下。

** 宏与编译

 #+BEGIN_QUOTE
You might ask why we take the trouble to compute an expansion for a macro and then evaluate the expansion. Why not have the macro body produce the desired results directly? The reason has to do with compilation.
 #+END_QUOTE

当宏调用出现在将要被编译的 Lisp 程序中时，Lisp 编译器会像解释器一样调用宏定义，然后得到宏展开的结果。但与解释器不同的是，编译器不会继续求值，而是将展开结果插入到程序中。这样一来，编译后的代码可以完成宏的功能，又可以利用编译码的速度。如果宏展开期间有副作用的话是不能这样做的，因为编译器的副作用对运行时没有作用。

为了让宏调用的编译能够进行，在编译宏调用时被调宏必须事先定义。编译器的一个特性可以帮到你：如果文件中包含 =defmacro= 宏定义的话，这个宏在文件编译期间会被临时定义。

对文件进行字节编译时也会执行任何 top-level 的 =require= 调用，你可以通过 =require= 定义宏的文件来确保必要的宏定义在编译期间是可用的。要避免编译后对文件的 require 引入不必要的宏的话，可以使用 =eval-when-compile= 来处理只在编译器使用的 =require= ，就像这样：

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'some-compile-macro))
#+END_SRC

** 编译时求值（eval）

在宏展开时，在宏体中对宏的参数表达式求值可能会带来一些问题。如果用户碰巧使用了和宏的形参名字相同的实参的话会出现问题，就像这样：

#+BEGIN_SRC emacs-lisp
;;with lexical-binding set to nil
(defmacro foo (a)
  (list 'setq (eval a) t))

(setq x 'b)
(foo x) => (setq b t) => t

(setq a 'c)
(foo a) => (setq a t) => t ; but set a, not c
#+END_SRC

出现这个问题的原因在于，宏的形参 =a= 绑定了符号 'a，由于动态作用域的关系，a 对符号 c 的绑定在宏展开时暂时被遮蔽了，所以 (eval a) 会得到符号 a 而不是 c。（不过话又说回来，如果打开词法作用域的话就不会有问题了，因为词法作用域的绑定不会改变外面符号绑定的值，而 eval 又是在空环境（全局环境）中求值的，所以没有问题）

除了说上面的遮蔽问题外，展开时求值对宏的编译也是不利的。在编译时编译器会执行宏定义，但这时被 eval 的变量可能还不存在。

manual 上对此的建议是：不要在宏展开时对参数表达式进行求值，而是将求值的部分留到宏的展开结果中，这样就可以在运行时求值了。

** 宏的多次展开

如果宏在展开过程中含有副作用的话，宏的行为可能会与宏的展开次数有关。你应该尽量避免宏展开中的副作用，除非你十分清楚你要做什么。

但并不是所有的副作用都能被避免的，比如在展开时构建 Lisp 对象。几乎所有的宏展开都包括构建表这一过程，这也是大多数宏的全部工作，它一般是很安全的。但有一种情况是你必须要注意的：当你构建的对象是宏展开中带引用常值的一部分时。

在大多数的 Lisp 代码中是不需要关心这个问题的。只要你在对宏定义中构建的对象进行带副作用操作时这个问题才变得重要。要避免这个问题，你最好在由宏定义构建的对象中避免任何的副作用操作。

下面的代码可以用来说明这个问题：

#+BEGIN_SRC emacs-lisp
(defmacro empty-object ()
  (list 'quote (cons nil nil)))

(defun initialize (condition)
  (let ((object (empty-object)))
    (if condition
        (setcar object condition))
      object))
#+END_SRC

每当 =initialize= 被调用时，一个新的 =(nil)= 就会被创建。所以不用担心各个调用之间的副作用问题。但是如果上面的代码被编译了，那么 initialize 中的 =(empty-object)= 调用会被展开，并在之后所有对 initialize 调用过程中重复使用。这显然不是我们想要看到的。

避免这种病态情况的一种方法是将空对象视为常量（即 '(nil)），你不会在 '(nil) 之类的常量上使用 setcar，因此自然也不会在 (empty-object) 上使用它。

** 其他建议

- 请注意不要在宏展开期间完成运行时的工作，记得一定要返回一个表达式
- 注意宏参数在展开表达式中的求值次数，写的好的宏会注意避免掉对某个表达式的重复求值
- 注意名字冲突问题，使用 =make-symbol= 或 =gensym= 等工具来解决问题

* 一些工具函数和宏

上面的各小节基本涵盖了 manual 中 macro 一章的所有内容，但光凭这些干巴巴的东西还不足以让你写出好看好用的宏。这一小节的任务是简单介绍一些可以在宏定义中使用的工具宏，以及一些更加实际的例子。
