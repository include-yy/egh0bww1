#+SETUPFILE: ../../setup.org
#+TITLE: emacs 中的 list 函数
#+TITLE: @@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzMxMzAxMTE=.jpg" alt="load failed"></div>@@
#+DATE: [2021-09-04 Sat]
#+TAGS: emacs

本着把文档上每一个函数都敲一遍的理念，本文的目的是学习并记录 elisp 中表函数的用法。除了说 elisp manual 和 cl-lib 中的表函数，我还会介绍 dash.el，它是一个好用的表函数库。那为啥不介绍一下 list 这种数据结构呢？这是因为函数实在是太多了，干脆先拎出来讲讲，之后再写篇文章介绍 list 和 cons。

除了说罗列一大堆的函数外，我还会尝试对它们进行简单的分类，这样有利于你根据具体情况决定使用哪些函数。除了个别非常简单的函数，文中几乎所有的函数都会有例子。想要了解一下函数类别和函数数量的同学可以看看标题和函数的名字，想了解函数功能和使用方法的同学可以看看例子，什么都不想看的同学可以看看题图。

根据 dash 的分类和我的一些使用经验，我将它们分为以下几类。之后的每一类对应小节的开头都会列出该类的所有函数名和函数数量。

- 对表中元素的访问
- 获取表的子表

我使用的是 emacs 27.1 on windows，以下代码均可在该环境中正常执行。

* 表的创建与扩充
** 增加元素

 - push, add-to-list, add-to-ordered-list
 - cl-pushnew

 =push= 是一个宏，它接受一个元素和一个表变量，将元素添加到变量表的表首，并将得到的新表保存到变量中。它的作用是修改变量，而不是对原来的表进行修改。例子如下：

 #+BEGIN_SRC emacs-lisp
 (setq a '(1 2 3))
 (setq b a)
 (push 4 a)
 a -> (4 1 2 3)
 b -> (1 2 3)
 #+END_SRC

 =add-to-list= 与 =push= 相似，也是对变量进行修改得到添加元素后的表，但是如果要添加的元素已经在表中的话，它就不会进行添加。除了接受表变量和新元素外，它还接受 =append= 和 =compare-fn= 两个可选参数。如果 =append= 为非空，则新的元素会被添加到表的末尾，如果 =compare-fn= 是一个函数，则 =add-to-list= 会使用指定的函数来进行比较，默认情况下它使用 =equal= 。另外，文档中还提到不要对词法变量使用这个函数。

 =add-to-ordered-list= 的必须参数与 =add-to-list= 相同，但可选参数只有一个 =order= ，它用来指定添加元素的位置。与 =add-to-list= 不同的是，它使用 =eq= 来比较元素是否相等。如果要添加的元素不在表中的话，它会根据 =order= 被添加到表中，如果已经在表中，它的位置很根据 =order= 指定的数字进行调整。 =order= 是一个数字，表中元素的顺序是单调递增序列。

 如果 =order= 参数是 nil 的话，新的元素会被添加到表的末尾，这种添加是无序的，没有指定顺序的元素在表尾的顺序不是特定的。已存在的元素的数字顺序值不会改变，表的元素顺序信息存储在变量的 plist 属性 =list-order= 中。

 以下是使用这两个函数的例子：

 #+BEGIN_SRC emacs-lisp
 (setq foo '(a b))
 (add-to-list 'foo 'c) -> (c a b)
 (add-to-list 'foo 'b) -> (c a b)
 foo -> (c a b)

 (setq bar '())
 (add-to-ordered-list 'bar 'a 1) -> (a)
 (add-to-ordered-list 'bar 'c 3) -> (a c)
 (add-to-ordered-list 'bar 'b 2) -> (a b c)
 (add-to-ordered-list 'bar 'b 4) -> (a c b)
 (add-to-ordered-list 'bar 'd) -> (a c b d)
 (add-to-ordered-list 'bar 'e) -> (a c b e d)
 #+END_SRC

 与 =add-to-list= 相似的还有 =cl-pushnew= ，不过它默认使用 =eql= 来判断是否相等。可以使用 =:test= 关键字指定比较函数。


* 一些表的谓词
* 对表中元素的访问
** car, cdr 等 =48=

- =car=, =cdr=, =cx{2, 4}r= =30=
- =cl-first=, =cl-second= ... =cl-tenth= =10=
- =-first-item=, =-second-item= ... =-fifth-item=, =-last-item= =6=
- =car-safe=, =cdr-safe= =2=

=car= 和 =cdr= 可以说是 Lisp 中最经典的两个操作符了， =car= 取得 cons 的前部分， =cdr= 取得 cons 的后部分。除了这两个最基本的函数，elisp 中还提供了 =cx{2, 4}r= 共计 28 个扩展函数，其中 =x= 可以是 =a= 或 =d= ，它们的含义如下[fn::https://franz.com/support/documentation/ansicl.94/dictentr/carcdrca.htm]：

| (caar x)   | (car (car x))             |
| (cadr x)   | (car (cdr x))             |
| (cdar x)   | (cdr (car x))             |
| (cddr x)   | (cdr (cdr x))             |
| (caaar x)  | (car (car (car x)))       |
| (caadr x)  | (car (car (cdr x)))       |
| (cadar x)  | (car (cdr (car x)))       |
| (caddr x)  | (car (cdr (cdr x)))       |
| (cdaar x)  | (cdr (car (car x)))       |
| (cdadr x)  | (cdr (car (cdr x)))       |
| (cddar x)  | (cdr (cdr (car x)))       |
| (cdddr x)  | (cdr (cdr (cdr x)))       |
| (caaaar x) | (car (car (car (car x)))) |
| (caaadr x) | (car (car (car (cdr x)))) |
| (caadar x) | (car (car (cdr (car x)))) |
| (caaddr x) | (car (car (cdr (cdr x)))) |
| (cadaar x) | (car (cdr (car (car x)))) |
| (cadadr x) | (car (cdr (car (cdr x)))) |
| (caddar x) | (car (cdr (cdr (car x)))) |
| (cadddr x) | (car (cdr (cdr (cdr x)))) |
| (cdaaar x) | (cdr (car (car (car x)))) |
| (cdaadr x) | (cdr (car (car (cdr x)))) |
| (cdadar x) | (cdr (car (cdr (car x)))) |
| (cdaddr x) | (cdr (car (cdr (cdr x)))) |
| (cddaar x) | (cdr (cdr (car (car x)))) |
| (cddadr x) | (cdr (cdr (car (cdr x)))) |
| (cdddar x) | (cdr (cdr (cdr (car x)))) |
| (cddddr x) | (cdr (cdr (cdr (cdr x)))) |

在 CL 中还提供了从 =first= 到 =tenth= 十个函数，它们的作用是获取表的第一个到第十个元素。在 elisp 中可以使用 =cl-first= , =cl-second= ... =cl-tenth= 。在 dash.el 中也提供了从 1 到 5 的函数。即 =-first-item= 到 =fifth-item= 。除此之外，dash 还提供了访问最后一个元素的 =-last-item= 。

除了简单的 =car= 和 =cdr= ，elisp 还提供了 =car-safe= 和 =cdr-safe= 。在接受非 cons 类型的参数时它们不会像 =car= 和 =cdr= 一样直接报错，而是返回 nil。另外值得一提的是， elisp 中 =car= 和 =cdr= 在接受 nil 时会返回 nil ，而不是报错。

以下是上面部分函数的使用示例：

#+BEGIN_SRC emacs-lisp
(car-safe 1) => nil
(cdr-safe 1) => nil
(car nil) => nil
(cdr nil) => nil

(cl-fifth '(1 2 3 4 5)) => 5
(cadddr '(1 2 3 4 5)) => 4
(-fourth-item '(1 2 3 4 5)) => 4
(-last-item '(1 2 3 4 5)) => 5
#+END_SRC

** 按位置访问 =2=

- =nth= (N LIST)
- =elt= (SEQ N)

除了使用上面的一系列函数，你还可以使用 =nth= 来通过指定序号访问表中对应元素。与之相似的还有 =elt= ，不过它面向的是 =sequence= ，可以用在 list，string 和 vector 上。与 =nth= 不同的是，它指定位置的参数是第二个而不是第一个。

#+BEGIN_SRC emacs-lisp
(nth 2 '(1 2 3)) -> 3
(elt '(1 2 3) 2) -> 3
#+END_SRC

* 获取表的子表

集合中有子集的概念，那么类似地，表也应该有子表，就像 "lo" 是 "hello" 的子串一样。相比于集合式的散点，表是有结构的，它通过一个个箭头把元素串成一串。我认为需要根据是否保留所有元素，保留原表元素顺序，保留原表元素之间连接关系这三个指标来对子表进行分类：

- 表的复制，保留所有元素，保留顺序，保留连接关系，即和原表一模一样（equal）
- 从原表中截取一整段，保留顺序和连接关系（这是一般认为的子串）
- 从原表中删除个别元素，保留了顺序
- 从原表中取出元素按不同于原表的顺序组合，仅是集合意义上的子集

根据以上分类可以看出，一个串是某个串的子串的最低限度就是：该串的所有元素属于另一串。对于第四种，不如将它放到“将表作为集合”一节一起说明。

** 表的复制 =7=

- =cl-copy-list= (LIST), =-copy= (LIST), =copy-sequence= (ARG), =cl-copy-seq= (ARG)
- =copy-tree= (TREE &optional VECP), =-clone= (LIST)
- =copy-alist= (ALIST)

=cl-copy-list= ， =-copy= ， =copy-sequence= 和 =cl-copy-seq= 四个函数都接受一个表作为参数，并返回一个副本。它们不会拷贝表中的元素，表中元素的值会与原表共享。换句话说，它们进行的都是浅拷贝。如果使用 ='(((1)))= 来作为参数，这些函数返回的表的 =car= 部分的 =((1))= 是与原表共享的。

在文档中对 =cl-copy-seq= 和 =copy-sequence= 还做出了额外的说明：它们接受的参数可以是 vector，string 和其他序列。如果接受的序列是空的话，函数的返回值可能就是原来的对象。

以下代码可以体现出它们的用法，以及浅拷贝的特点：

#+BEGIN_SRC emacs-lisp
(setq a '((1)))
(setq b1 (cl-copy-list a))
(setq b2 (-copy a))
(setq b3 (copy-sequence a))
(setq b4 (cl-copy-seq a))
(list a b1 b2 b3 b4) => (((1)) ((1)) ((1)) ((1)) ((1)))
(setcar (car a) 2)
(list a b1 b2 b3 b4) => (((2)) ((2)) ((2)) ((2)) ((2)))
#+END_SRC

=copy-tree= 和 =-clone= 进行的则是深拷贝，它们能够识别出 cons 并拷贝到新表中，这样就不会与原表共享 cons 了。使用和上面一样的例子，我们可以得到不同的结果：

#+BEGIN_SRC emacs-lisp
(setq a '((1)))
(setq b1 (copy-tree a))
(setq b2 (-clone a))
(list a b1 b2) => ((1) (1) (1))
(setcar (car a) 2)
(list a b1 b2) => ((2) (1) (1))
#+END_SRC

=copy-tree= 还可以识别出 vector 并进行深拷贝，只需要指定可选参数为 t 即可：

#+BEGIN_SRC emacs-lisp
(setq a '((1) ([2 3 [4]])))
(setq b (copy-tree a t))
(list a b) => (((1) ([2 3 [4]])) ((1) ([2 3 [4]])))
(setcar (car a) 2)
(aset (aref (caadr a) 2) 0 1)
(list a b) => (((2) ([2 3 [1]])) ((1) ([2 3 [4]])))
#+END_SRC

=copy-alist= 的作用是拷贝一个关联表，相比于浅拷贝它还拷贝了每个关联项的 cons，不过它没有深拷贝关联项中的 =car= 和 =cdr= 部分，而是与原 alist 共用。

#+BEGIN_SRC emacs-lisp
(setq a '((1 . 2) ((2) . 3)))
(setq b (copy-alist a))
(setcar (car a) 2)
(setcar (caadr a) 3) a
(list a b) => (((2 . 2) ((3) . 3)) ((1 . 2) ((3) . 3)))
#+END_SRC

要说的话，使用 =-copy= 和 =-clone= 这两个函数就足够了，如果还要考虑拷贝嵌套的表和向量的话，可以使用 =copy-tree= 。

** 表的一部分 =12=

这一小节的函数可以从原表中拿出连续的一小段出来。从功能上说的话 =cdr= 应该也被归到这里，但是它与 =car= 的关系太密切了。

- =nthcdr= (N LIST), =last= (LIST &optional N), =butlast= (X &optional N), =nbutlast= (X &optional n), =-butlast= (LIST)
- =-take-last= (N LIST), =-drop= (N LIST), =-drop-while= (PRED LIST)
- =-take= (N LIST), =-drop-last= (N LIST), =-take-while= (PRED LIST)
- =-slice= (LIST FROM &optional TO STEP)

首先是 elisp 自带的四个函数， =nthcdr= ， =last= ， =butlast= 和 =nbutlast= 。 =nthcdr= 获取表的第 N 个 cdr，并返回这个值。 =last= 和 =butlast= 是相对的，前者取得由原表的后 N 个元素组成的表，它是原表的一部分，后者取得去掉原表后 N 个元素后的表的拷贝。 =nbutlast= 通过修改原表来去除后面的 N 个元素。

=last= ， =butlast= 和 =nbutlast= 的参数 N 都是可选的，如果不指定的话， =last= 获取表中的最后一个元素所在 cons， =butlast= 获取去掉最后一个元素的表的副本， =nbutlast= 去掉原表最后一个元素。 =-butlast= 就是不带可选参数的 =butlast= 。

#+BEGIN_SRC emacs-lisp
(nthcdr 2 '(1 2 3)) => (3)
(last '(1 2 3)) => (3)
(last '(1 2 3) 2) => (2 3)
(last '(1 2 3) -1) => nil
(last '(1 2 3) 0) => nil
(last '(1 2 3) 5) => (1 2 3)
(butlast '(1 2 3) 1) => (1 2)
(butlast '(1 2 3) 2) => (1)
(butlast '(1 2 3) 3) => nil
(butlast '(1 2 3) 5) => nil
(butlast '(1 2 3) 0) => (1 2 3)
(butlast '(1 2 3) -1) => (1 2 3)
(-butlast '(1 2 3)) => (1 2)

(setq a '(1 2 3))
(setq b (butlast a 1))
(setcar a 2)
(list a b) => ((2 2 3) (1 2))
(setq c (nbutlast a))
(list a c) ((2 2) (2 2))
(setcar a 3)
(list a c) ((3 2) (3 2))
#+END_SRC

=-take-last=  ， =-drop= 和 =-drop-while= 的作用就是拿掉表前面的元素。它们的不同之处在于 =-take-last= 是复制原表，而 =-drop= 和 =-drop-while= 是直接拿原表的一部分返回。与其他两个函数不同的是， =drop-while= 接受一个 =pred= 参数，它按照表的顺序以表元素为参数，若它返回非空值则从表中拿掉元素继续向下，若返回 nil 则停止并返回剩余的表。

#+BEGIN_SRC emacs-lisp
(mapcar (lambda (x) (-take-last x '(1 2 3)))
        '(-1 0 1 2 3 4))
=> (nil nil (3) (2 3) (1 2 3) (1 2 3))

(mapcar (lambda (x) (-drop x '(1 2 3)))
        '(-1 0 1 2 3 4))
=> ((1 2 3) (1 2 3) (2 3) (3) nil nil)

(-drop-while (lambda (x) (< x 3)) '(1 2 3)) => (3)
#+END_SRC

=-take= ， =-drop-last= 和 =-take-while= 和上面三个函数功能相反，它们获取表前端的元素。它们都返回一个新的表，而不是原表。

#+BEGIN_SRC emacs-lisp
(mapcar (lambda (x) (-take x '(1 2 3)))
        '(-1 0 1 2 3 4))
=> (nil nil (1) (1 2) (1 2 3) (1 2 3))

(mapcar (lambda (x) (-drop-last x '(1 2 3)))
        '(-1 0 1 2 3 4))
=> ((1 2 3) (1 2 3) (1 2) (1) nil nil)

(-take-while (lambda (x) (< x 3)) '(1 2 3)) => (1 2)
#+END_SRC

=-slice= 就像 =substring= 一样，可以从表的中间部分获取一个子表，不过它的参数比 =substing= 灵活的多。 =FROM= 和 =TO= 是可以为负数的，不过它们会被以表长取模得到正数，就像对于 =(1 2 3)= ，如果 =FROM= 或 =TO= 为 -13，得到的就是 -13 % 3 + 3 = 2。 =STEP= 是一个数字，如果不指定的话步长默认为 1，它的正负与否对步长绝对值没有影响。

#+BEGIN_SRC emacs-lisp
(-slice '(1 2 3) 1 2) => (2)
(-slice '(1 2 3) 1 -1) => (2)
(-slice '(1 2 3) -2 -1) => (2)
(-slice '(1 2 3) 0 3) => (1 2 3)
(-slice '(1 2 3) 0 100) => (1 2 3)
(-slice '(1 2 3) 100 101) => nil
(-slice '(1 2 3 4 5) 0 5 2) => (1 3 5)
(-slice '(1 2 3 4 5) 0 5 -2) => (1 3 5)
#+END_SRC

** 移除部分元素 =21=

这一节介绍的函数从原表中移除某些元素，但不改变原表中的元素顺序。

- =remq= (ELT LIST), =remove= (ELT SEQ), =cl-remove= (ITEM SEQ ...)
- =cl-remove-if= (PRED SEQ ...), =cl-remove-if-not= (PRED SEQ ...)
- =delq= (ELT LIST), =delete= (ELT LIST), =cl-delete= (ITEM SEQ ...)
- =cl-delete-if= (PRED SEQ ...), =cl-delete-if-not= (PRED SEQ ...)
- =delete-dups= (LIST), =delete-consecutive-dups= (LIST &optional CIRCULAR)
- =cl-remove-duplicates= (SEQ ...), =cl-delete-duplicates= (SEQ ...)
- =-remove-item= (ITEM LIST), =-filter= (PRED LIST), =-remove= (PRED LIST), =-remove-first= (PRED LIST), =-remove-last= (PRED LIST)
- =-non-nil= (LIST), =-distinct= (LIST)

=remq= 接受一个 ELT 和一个 LIST，在 LIST 中出现的所有 ELT 都会被去除掉。该函数返回去除元素后原表的副本，且使用 =eq= 来判断原表中元素是否等于参数 ELT。与之相比， =remove= 使用 =equal= 来进行比较，且接受的序列不限于表，还可以是向量和字符串。

#+BEGIN_SRC emacs-lisp
(remq 'a  '(a b c)) => (b c)
(remq 'l '(h e l l o)) => (h e o)
(remove 'l '(g a l g a m e)) => (g a g a m e)
(remove '(1) '((1) (1) (4) (5) (1) (4))) => ((4) (5) (4))
#+END_SRC

接下来就是 =cl-remove= ， =cl-remove-if= 和 =cl-remove-if-not= 三个函数。从某种意义上来说，后两个函数就是第一个函数的特化版。 =cl-remove= 默认使用 =eql= 进行比较，除了接受 ELT 和 SEQ 外，还可以使用关键字指定参数：

- =:test= 可以指定用于比较的函数，若函数返回非 nil 则移除比较的元素，它接受两个参数，第一参数的值即 ITEM
- =:test-not= 与 =:test= 相似，不过若它返回 nil 才移除比较元素
- =:key= 指定对表中元素进行的操作，它是一个单参数函数，函数的返回值被用来进行比较
- =:count= 指定替换个数，它是一个整数
- =:start= 指定 remove 操作的起始位置
- =:end= 指定 remove 操作的终止位置
- =:from-end= 表明从后往前进行 remove

为啥说 =cl-remove-if= 和 =cl-remove-if-not= 是 =cl-remove= 的特化呢？因为它们的关键字参数中没有 =:test= 和 =:test-not= ，这两个函数的 =pred= 参数分别起到 =:test= 和 =:test-not= 的作用，不过它们的函数参数都是单参数函数，以表的元素来作为参数。

#+BEGIN_SRC emacs-lisp
(cl-remove 1 '(1 2 3 1)) => (2 3)
(cl-remove 1 '(1 2 3 1) :count 1) => (2 3 1)
(cl-remove 1 '(1 2 3 1) :count 1 :from-end t) => (1 2 3)
(cl-remove 1 '(1 2 3 1) :start 1) => (1 2 3)
(cl-remove 1 '(1 2 3 1) :end 3) => (2 3 1)
(cl-remove 1 '(1 2 3 1) :key '1-) => (1 3 1)
(cl-remove nil '(1 2 3 1) :test (lambda (x y) (= y 1))) => (2 3)
(cl-remove nil '(1 2 3 1) :test-not (lambda (x y) (= y 1))) => (1 1)
(cl-remove 1.1 '(1.1 2 3)) => (2 3)
(cl-remove 1.1 '(1.1 2 3) :test 'eq) => (1.1 2 3)
(cl-remove 1.1 '(1.1 2 3) :test 'equal) => (2 3)

(cl-remove-if (lambda (x) (eq x 1)) '((1) (2) (3) (1)) :key 'car) => ((2) (3))
(cl-remove-if-not (lambda (x) (eq x 1)) '((1) (2) (3) (1)) :key 'car) => ((1) (1))
#+END_SRC

=delete= 系列的五个函数 =delq= ， =delete= ， =cl-delete= ， =cl-delete-if= ， =cl-delete-if-not= 和 =remove= 系列的函数功能几乎一致，但是它们不是返回拷贝的表，而是直接修改原表来得到结果。elisp manual 建议使用 setq 来确保获得改变后的表。

#+BEGIN_SRC emacs-lisp
(setq a '(1 2 3))
(setq a (delq 1 a)) => (2 3)
(setq b '((1) (2) (3)))
(setq b (delete '(1) b)) => ((2) (3))
(setq c '(1 2 3 4 5))
(setq c (cl-delete 5 c)) => (1 2 3 4)
(setq c (cl-delete-if 'cl-evenp c)) => (1 3)
(setq c (cl-delete-if-not 'cl-evenp c)) => nil
#+END_SRC

接下来的函数 =delete-dups= 和 =delete-consecutive-dups= 的功能是删除表中重复的元素，不过后者只会删除靠在一起的相同元素。它们都使用 =equal= 进行比较，且都通过修改原表来实现功能。 =cl-delete-duplicates= 和 =cl-remove-duplicates= 的功能也是删除重复元素，不过后者会返回拷贝的表而不是原表，它们的默认比较函数是 =eql= ，且支持 =:test= ， =:test-not= ， =:key= ， =:start= ， =:end= ， =:from-end= 关键字。

#+BEGIN_SRC emacs-lisp
(setq a '(a a b c d a d b))
(setq a (delete-dups a)) => (a b c d)
(setq a '(a a b c d a d d b))
(setq a (delete-consecutive-dups a)) => (a b c d a d b)

(setq a '(1 1 2 1))
(setq a (cl-delete-duplicates a)) => (2 1)
(setq a '(1 1 2 1))
(cl-remove-duplicates a) => (2 1)
#+END_SRC

根据上面的例子可以看出， =delete-dups= 会保留第一次出现的重复元素，而 =cl-*-duplicates= 会保留最后一次出现的元素。

接下来就是一系列的 dash 函数。 =-remove-item= 和 =remove= 一样使用 =equal= 比较， =-remove= 和 =cl-remove-if= 差不多， =-filter= 和 =cl-remove-if-not= 差不多， =-remove-first= 和 =-remove-last= 相当于 =cl-remove-if= 指定 =:count= 为 1 的情况下是否指定 =:from-end= 。

#+BEGIN_SRC emacs-lisp
(-remove-item '(1) '((1) (1) (2) (3))) => ((2) (3))
(-filter 'cl-oddp '(1 2 3 4 5)) => (1 3 5)
(-remove 'cl-oddp '(1 2 3 4 5)) => (2 4)
(-remove-first 'cl-oddp '(1 2 3)) => (2 3)
(-remove-last 'cl-oddp '(1 2 3)) => (1 2)
#+END_SRC

最后就是 dash 里面的消除重复的函数了。 =-non-nil= 去除表中所有的 nil 并返回一个副本， =-distinct= 去除所有的重复元素，并返回一个副本。它默认使用 =equal= 进行比较，可以通过指定变量 =-compare-fn= 的值来选择比较函数。

#+BEGIN_SRC emacs-lisp
(-non-nil '(1 2 nil 3 4 nil)) => (1 2 3 4)
(-distinct '((1) (1) (2) (3) (1))) => ((1) (2) (3))
(let ((-compare-fn 'eq)) (-distinct '((1) (1) (2) (3)))) => ((1) (1) (2) (3))
#+END_SRC

* 表的查找与替换

查找和替换是编辑器应该具有的基础功能。以它们作为表操作的一种分类应该是较合理的。

** 查找 =21=

- =memq=, =memql=, =member=, =member-ignore-case= (OBJECT LIST)
- =cl-member= (CL-ITEM CL-LIST &rest CL-KEYS), =cl-member-if=, =cl-member-if-not= (PRED LIST &rest KEYS)
- =cl-find= (ITEM SEQ), =cl-find-if=, =cl-find-if-not= (PRED LIST &rest KEYS)
- =cl-position= (ITEM SEQ), =cl-position-if=, =cl-position-if-not= (PRED LIST &rest KEYS)
- =cl-search= (SEQ1 SEQ2 &rest KEYS)
- =-first=, =-last= (PRED LIST)
- =-elem-index=, =-elem-indices= (ELEM LIST)
- =-find-index=, =-find-last-index=, =-find-indices= (PRED LIST)



* 参考资料

【1】https://franz.com/support/documentation/ansicl.94/ansicl.htm
【2】

@@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly95YW5kZS5yZS9wb3N0L3Nob3cvMTQ0NzE1.jpg" alt="load failed"></div><div class="yyimgcomment">izayoi sakuya</div>@@
* dash [30/176]

- [ ] -map (fn list)
- [ ] -map-when (pred rep list)
- [ ] -map-first (pred rep list)
- [ ] -map-last (pred rep list)
- [ ] -map-indexed (fn list)
- [ ] -annotate (fn list)
- [ ] -splice (pred fun list)
- [ ] -splice-list (pred new-list list)
- [ ] -mapcat (fn list)
- [X] -copy (list)

- [X] -filter (pred list)
- [X] -remove (pred list)
- [X] -remove-first (pred list)
- [X] -remove-last (pred list)
- [X] -remove-item (item list)
- [X] -non-nil (list)
- [X] -slice (list from &optional to step)
- [X] -take (n list)
- [X] -take-last (n list)
- [X] -drop (n list)
- [X] -drop-last (n list)
- [X] -take-while (pred list)
- [X] -drop-while (pred list)
- [ ] -select-by-indices (indices list)
- [ ] -select-columns (columns table)
- [ ] -select-column (column table)

- [ ] -keep (fn list)
- [ ] -concat (&rest lists)
- [ ] -flatten (l)
- [ ] -flatten-n (num list)
- [ ] -replace (old new list)
- [ ] -replace-first (old new list)
- [ ] -replace-last (old new list)
- [ ] -insert-at (n x list)
- [ ] -replace-at (n x list)
- [ ] -update-at (n func list)
- [ ] -remove-at (n list)
- [ ] -remove-at-indices (indices list)

- [ ] -reduce-from (fn init list)
- [ ] -reduce-r-from (fn init list)
- [ ] -reduce (fn list)
- [ ] -reduce-r (fn list)
- [ ] -reductions-from (fn init list)
- [ ] -reductions-r-from (fn init list)
- [ ] -reductions (fn list)
- [ ] -reductions-r (fn list)
- [ ] -count (pred list)
- [ ] -sum (list)
- [ ] -running-sum (list)
- [ ] -product (list)
- [ ] -running-product (list)
- [ ] -inits (list)
- [ ] -tails (list)
- [ ] -common-prefix (&rest lists)
- [ ] -common-suffix (&rest lists)
- [ ] -min (list)
- [ ] -min-by (comparator list)
- [ ] -max (list)
- [ ] -max-by (comparator list)

- [ ] -iterate (fun init n)
- [ ] -unfold (fun seed)

- [ ] -some (pred list)
- [ ] -every (pred list)
- [ ] -any? (pred list)
- [ ] -all? (pred list)
- [ ] -none? (pred list)
- [ ] -only-some? (pred list)
- [ ] -contains? (list element)
- [ ] -same-items? (list list2)
- [ ] -is-prefix? (prefix list)
- [ ] -is-suffix? (suffix list)
- [ ] -is-infix? (infix list)
- [ ] -cons-pair? (obj)

- [ ] -split-at (n list)
- [ ] -split-with (pred list)
- [ ] -split-on (item list)
- [ ] -split-when (fn list)
- [ ] -separate (pred list)
- [ ] -partition (n list)
- [ ] -partition-all (n list)
- [ ] -partition-in-steps (n step list)
- [ ] -partition-all-in-steps (n step list)
- [ ] -partition-by (fn list)
- [ ] -partition-by-header (fn list)
- [ ] -partition-after-pred (pred list)
- [ ] -partition-before-pred (pred list)
- [ ] -partition-before-item (item list)
- [ ] -partition-after-item (item list)
- [ ] -group-by (fn list)

- [X] -elem-index (elem list)
- [X] -elem-indices (elem list)
- [X] -find-index (pred list)
- [X] -find-last-index (pred list)
- [X] -find-indices (pred list)
- [ ] -grade-up (comparator list)
- [ ] -grade-down (comparator list)

- [ ] -union (list list2)
- [ ] -difference (list list2)
- [ ] -intersection (list list2)
- [ ] -powerset (list)
- [ ] -permutations (list)
- [X] -distinct (list)

- [ ] -rotate (n list)
- [ ] -repeat (n x)
- [ ] -cons* (&rest args)
- [ ] -snoc (list elem &rest elements)
- [ ] -interpose (sep list)
- [ ] -interleave (&rest lists)
- [ ] -iota (count &optional start step)
- [ ] -zip-with (fn list1 list2)
- [ ] -zip (&rest lists)
- [ ] -zip-lists (&rest lists)
- [ ] -zip-fill (fill-value &rest lists)
- [ ] -unzip (lists)
- [ ] -cycle (list)
- [ ] -pad (fill-value &rest lists)
- [ ] -table (fn &rest lists)
- [ ] -table-flat (fn &rest lists)
- [X] -first (pred list)
- [X] -last (pred list)
- [X] -first-item (list)
- [X] -second-item (list)
- [X] -third-item (list)
- [X] -fourth-item (list)
- [X] -fifth-item (list)
- [X] -last-item (list)
- [X] -butlast (list)
- [ ] -sort (comparator list)
- [ ] -list (arg)
- [ ] -fix (fn list)

- [ ] -tree-seq (branch children tree)
- [ ] -tree-map (fn tree)
- [ ] -tree-map-nodes (pred fun tree)
- [ ] -tree-reduce (fn tree)
- [ ] -tree-reduce-from (fn init-value tree)
- [ ] -tree-mapreduce (fn folder tree)
- [ ] -tree-mapreduce-from (fn folder init-value tree)
- [X] -clone (list)

- [ ] -> (x &optional form &rest more)
- [ ] ->> (x &optional form &rest more)
- [ ] --> (x &rest forms)
- [ ] -as-> (value variable &rest forms)
- [ ] -some-> (x &optional form &rest more)
- [ ] -some->> (x &optional form &rest more)
- [ ] -some--> (expr &rest forms)
- [ ] -doto (init &rest forms)

- [ ] -when-let ((var val) &rest body)
- [ ] -when-let* (vars-vals &rest body)
- [ ] -if-let ((var val) then &rest else)
- [ ] -if-let* (vars-vals then &rest else)
- [ ] -let (varlist &rest body)
- [ ] -let* (varlist &rest body)
- [ ] -lambda (match-form &rest body)
- [ ] -setq ([match-form val] ...)

- [ ] -each (list fn)
- [ ] -each-while (list pred fn)
- [ ] -each-indexed (list fn)
- [ ] -each-r (list fn)
- [ ] -each-r-while (list pred fn)
- [ ] -dotimes (num fn)

- [ ] -partial (fun &rest args)
- [ ] -rpartial (fn &rest args)
- [ ] -juxt (&rest fns)
- [ ] -compose (&rest fns)
- [ ] -applify (fn)
- [ ] -on (op trans)
- [ ] -flip (fn)
- [ ] -rotate-args (n fn)
- [ ] -const (c)
- [ ] -cut (&rest params)
- [ ] -not (pred)
- [ ] -orfn (&rest preds)
- [ ] -andfn (&rest preds)
- [ ] -iteratefn (fn n)
- [ ] -fixfn (fn &optional equal-test halt-test)
- [ ] -prodfn (&rest fns)
* elisp manual [0/9]
- [ ] cons cells
- [ ] list-related predicates
- [ ] list elements
- [ ] building lists
- [ ] list variables
- [ ] modifying lists
- [ ] Set And Lists
- [ ] Association Lists
- [ ] Property Lists
* cl-lib [0/86]
- [ ] (defmacro cl-pushnew (x place &rest keys)
- [ ] (defun cl-mapcar (cl-func cl-x &rest cl-rest)
- [ ] (defun cl-list* (arg &rest rest)
- [ ] (defun cl-ldiff (list sublist)
- [ ] (defun cl-copy-list (list)
- [ ] (defun cl-adjoin (cl-item cl-list &rest cl-keys)
- [ ] (defun cl-subst (cl-new cl-old cl-tree &rest cl-keys)
- [ ] (defun cl-acons (key value alist)
- [ ] (defun cl-pairlis (keys values &optional alist)

- [ ] (defun cl-map (cl-type cl-func cl-seq &rest cl-rest)
- [ ] (defun cl-maplist (cl-func cl-list &rest cl-rest)
- [ ] (defun cl-mapc (cl-func cl-seq &rest cl-rest)
- [ ] (defun cl-mapl (cl-func cl-list &rest cl-rest)
- [ ] (defun cl-mapcan (cl-func cl-seq &rest cl-rest)
- [ ] (defun cl-mapcon (cl-func cl-list &rest cl-rest)
- [ ] (defun cl-some (cl-pred cl-seq &rest cl-rest)
- [ ] (defun cl-every (cl-pred cl-seq &rest cl-rest)
- [ ] (defun cl-notany (cl-pred cl-seq &rest cl-rest)
- [ ] (defun cl-notevery (cl-pred cl-seq &rest cl-rest)
- [ ] (defun cl-subseq (seq start &optional end)
- [ ] (defun cl-concatenate (type &rest sequences)
- [ ] (defun cl-revappend (x y)
- [ ] (defun cl-nreconc (x y)
- [ ] (defun cl-list-length (x)
- [ ] (defun cl-tailp (sublist list)
- [ ] (defun cl-getf (plist tag &optional def)

- [ ] (defun cl-endp (x)
- [ ] (defun cl-reduce (cl-func cl-seq &rest cl-keys)
- [ ] (defun cl-fill (cl-seq cl-item &rest cl-keys)
- [ ] (defun cl-replace (cl-seq1 cl-seq2 &rest cl-keys)
- [ ] (defun cl-remove (cl-item cl-seq &rest cl-keys)
- [ ] (defun cl-remove-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-remove-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-delete (cl-item cl-seq &rest cl-keys)
- [ ] (defun cl-delete-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-delete-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-remove-duplicates (cl-seq &rest cl-keys)
- [ ] (defun cl-delete-duplicates (cl-seq &rest cl-keys)
- [ ] (defun cl-substitute (cl-new cl-old cl-seq &rest cl-keys)
- [ ] (defun cl-substitute-if (cl-new cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-substitute-if-not (cl-new cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-nsubstitute (cl-new cl-old cl-seq &rest cl-keys)
- [ ] (defun cl-nsubstitute-if (cl-new cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-nsubstitute-if-not (cl-new cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-find (cl-item cl-seq &rest cl-keys)
- [ ] (defun cl-find-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-find-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-position (cl-item cl-seq &rest cl-keys)
- [ ] (defun cl-position-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-position-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-count (cl-item cl-seq &rest cl-keys)
- [ ] (defun cl-count-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-count-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-mismatch (cl-seq1 cl-seq2 &rest cl-keys)
- [ ] (defun cl-search (cl-seq1 cl-seq2 &rest cl-keys)
- [ ] (defun cl-sort (cl-seq cl-pred &rest cl-keys)
- [ ] (defun cl-stable-sort (cl-seq cl-pred &rest cl-keys)
- [ ] (defun cl-merge (cl-type cl-seq1 cl-seq2 cl-pred &rest cl-keys)
- [ ] (defun cl-member (cl-item cl-list &rest cl-keys)
- [ ] (defun cl-member-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-member-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-assoc (cl-item cl-alist &rest cl-keys)
- [ ] (defun cl-assoc-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-assoc-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-rassoc (cl-item cl-alist &rest cl-keys)
- [ ] (defun cl-rassoc-if (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-rassoc-if-not (cl-pred cl-list &rest cl-keys)
- [ ] (defun cl-union (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-nunion (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-intersection (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-nintersection (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-set-difference (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-nset-difference (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-set-exclusive-or (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-nset-exclusive-or (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-subsetp (cl-list1 cl-list2 &rest cl-keys)
- [ ] (defun cl-subst-if (cl-new cl-pred cl-tree &rest cl-keys)
- [ ] (defun cl-subst-if-not (cl-new cl-pred cl-tree &rest cl-keys)
- [ ] (defun cl-nsubst (cl-new cl-old cl-tree &rest cl-keys)
- [ ] (defun cl-nsubst-if (cl-new cl-pred cl-tree &rest cl-keys)
- [ ] (defun cl-nsubst-if-not (cl-new cl-pred cl-tree &rest cl-keys)
- [ ] (defun cl-sublis (cl-alist cl-tree &rest cl-keys)
- [ ] (defun cl-nsublis (cl-alist cl-tree &rest cl-keys)
- [ ] (defun cl-tree-equal (cl-x cl-y &rest cl-keys)

- [ ] (defmacro cl-shiftf (place &rest args)
- [ ] (defmacro cl-rotatef (&rest args)
