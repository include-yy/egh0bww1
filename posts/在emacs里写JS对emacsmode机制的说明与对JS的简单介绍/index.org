#+SETUPFILE: ../../setup.org
#+TITLE: 在 emacs 里写 JS —— 对 JS 的简单介绍与对 emacs mode 机制的说明
#+TITLE: @@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzY4OTMxMjM3.jpg" alt="load failed"></div>@@
#+DATE: [2022-10-19 Wed 15:28]
#+TAGS: emacs js

JS，也就是 JavaScript，应该是我接触的第四还是第五种编程语言，我对它的最初印象是和 Python 有点像的动态语言。在写过一些 toy program 和看过一些 meme 后我对它有了一些了解，也就有兴趣来为它折腾一下 emacs 的相关配置，毕竟 /Any application that can be written in JavaScript, will eventually be written in JavaScript. -- Atwood's Law/ 。我并不怎么讨厌 JS，倒不如说比较喜欢，不过这可能是因为我没有长时间深入地用过它。

在写这篇文章之前我在 emacs 里配置“开发环境”一般是加上 major-mode 就完事，也没有详细了解过 mode 的实现原理。本文中对 JS 的配置是我第一次比较正式的配置，我会较详细地介绍 major-mode 和 minor-mode 的实现和使用，以及一些 emacs 与外部应用的交互方法。

文章的后半段就是在 emacs 中详细配置 JS 的思路和代码插件了，我会参考现在的编辑器（比如 vscode）和 IDE（比如 WebStorm）列出一些常用的辅助功能，然后依照这些来配置 emacs。

要说的话文章的前半段和后半段已经没啥联系了，把对 JS 的介绍和对象的介绍这两节拿出来可以单独成文。但是拿掉之后折腾 emacs mode 的目的就无法体现了，而且文章前半段对完全不懂 JS 的读者还是有些参考意义的（希望如此）。 +所以虽然本文从内容上看可以分为单独两篇，我们还是按照文本量分为上下两篇。+

本文内容如下：

- 什么是 JavaScript
- 提一嘴 OOP

- 编辑器/IDE 都提供了哪些功能
- emacs 的 major mode
- emacs 的 minor mode
- emacs 与外部程序的交互
- 在 emacs 中配置 JavaScript

本文使用的环境如下：

- Windows 10 家庭中文版 21H2 19044.2130
- emacs 28.1 x86_64
- node v16.18.0
- Python 3.9.6 65-bit
- Firefox 105.0.3 (64 位)

若不作特别说明，出现的 JavaScript 代码在 Firefox 的控制台（ =F12= ）中运行。

* 什么是 JavaScript

在开始这一节之前我们先来点 JS [[https://www.yazeedb.com/posts/explaining-the-best-javascript-meme-i-have-ever-seen][meme]]：

| [[./1.png]] | [[./2.jpg]] | [[./3.jpg]] |
| [[./4.jpg]] | [[./5.jpg]] | [[./6.jpg]] |
| [[./7.jpg]] | [[./8.jpg]] | [[./9.jpg]] |

上面几张图主要体现的还是 JS 鬼畜的隐式类型转换、callback hell 和全栈能力。下面我们从 JS 诞生时开始讲起。要让作为 JS 小白的我讲清楚一门如此庞大繁杂的语言实在不太可能，我没能力把 JS 的历史讲的妙趣横生，也不能对语言中的各种细节信手拈来，如果你从中发现了错误，欢迎指正，我会及时修正。

下一节主要参考了维基百科的 [[https://en.wikipedia.org/wiki/JavaScript][JavaScript]] 页面。

** JavaScript 简史

JavaScript 诞生于 1995 年 12 月 4 日，作者是 Brendan Eich，如下图所示：

@@html:<div class="yyheadimg"><img src="./10.jpg" alt="load failed"></div>@@

关于 JS 的一个比较有趣的传闻是 Brendan Eich 用了十天就完成了语言设计，为了蹭 Java 的名气最后取了 JavaScript 这个名字，当然这也是真事就是了，Java 和 JavaScript 的关系就像雷锋和雷峰塔一样。JavaScript 是为了做浏览器脚本语言这个目的而诞生的，它借鉴了多种语言的特性：基本就是 C 的语法，从 Self 语言借鉴了对象原型链，从 Java 借鉴了面向对象的写法，从 Scheme 学来了 first-class function，等等，总之就是个四不像的缝合怪。

1995 年正值第一次浏览器[[https://en.wikipedia.org/wiki/Browser_wars][大战]]的开始，看着 Netscape 这边有了 JavaScript，微软的也给 IE 弄了个类似的语言，叫做 JScript，在 1996 年发布。JScript 和 JavaScript 有比较明显的区别，这对开发者来说当然很不好，对不同的浏览器需要编写不同的代码。1996 年的 11 月 Netscape 向 Ecma 提交了 JavaScript，这也是 JavaScript 标准化的开始。1997 年 6 月 ES1 标准发布，1998 年 6 月 ES2 标准发布，1999 年 12 月 ES3 标准发布。ES4 标准的制定在 2000 年开始（但是最后成了废案）。

照维基百科的说法，第一次浏览器大战从 1995 年打到 2001 年，由 Netscape 对战 Microsoft，最后以 IE 的胜利收场。二十一世纪的头几年 IE 的市场占有率达到了 90% 左右，JScript 这是也成了 Web 客户端脚本的事实标准（de facto standard）。微软一开始还选择性地在 JScript 中实现一些 ES 标准特性，但是最终它放弃了相关支持，这也是 ES4 最后被废除的一个很大原因。

微软在二十一世纪头几年对浏览器的垄断让 JavaScript 的发展停滞了几年，但垄断也没能一直持续下去。在 2004 年，Netscape 的继任者 Mozilla 发布了 Firefox 浏览器，随后的一段时间从 IE 手里抢走了不少市场占有率。2005 年 Mozilla 加入了 ECMA，参与了一些标准化的工作，其中发生了一些事情（具体见 wiki）导致 ES4 的标准化难以进行。这一时期开源社区也有了一些非常重要的发展，比如 Ajax，jQuery 等开源项目。谷歌在 2008 年发布了 Chrome 浏览器，其中的 JavaScript 引擎 V8 比市面上的其他实现都快，它使用了 JIT 编译技术。

在 2009 年的 12 月发生了一件大事，那就是 ES5 标准的发布。这一标准作为最新标准存在了 6 年之久，并在 2015 年被新的 ES6 标准取代。ES6 是非常重要的一版标准，它继承了大部分 ES4 中的内容，引入了非常多的有用特性。此后每一年出一个新的标准，现在已经到了 ES13 了。除了语言标准的稳步迭代外，node 的出现也赋予了 JavaScript 更多的可能。2009 年 Ryan Dahl 创建了 Node.js，这也使得在浏览器外对 JavaScript 的使用激增。node 使用了 V8 引擎，提供了一个浏览器外独立的 JavaScript 运行时系统。node.js 的包管理器 npm 是世界上拥有包数最多的包管理器。

到了现在，JavaScript 给我的感觉就是什么都能做。现在除了使用 JS 外还有许多编译到 JS 的语言可以用，JS 俨然成了 Web 汇编。

*/Any application that can be written in JavaScript, will eventually be written in JavaScript./*

** 作为程序语言的 JavaScript

#+BEGIN_QUOTE
我们说学习一门语言一般包含两个方面
- 这门语言的思考方式，比如 C++ 对于 C 所添加的面向对象，泛型编程，prolog 的逻辑编程，ReScript 的函数编程以及基于数据类型的思维
- 这门语言的运行时，工具链和生态系统，如 Java 里面 JVM 调优, scala 里面的 sbt 构建系统，以及各种框架

作者：张宏波

链接：https://www.zhihu.com/question/479243721/answer/2062068827
#+END_QUOTE

还是上面那句话，对于 JS 小白的我来说谈论 JS 这门语言力所不逮了属于是，这里只能做一些拾人牙慧的工作，然后混入一些自己的理解了。这一小节我们简单说说作为编程语言的 JS，下面主要参考了 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_overview][MDN]] 文档。

作为一门用了十天就设计出来的语言，我们也没必要指望它能好到哪里去，不过在标准的不断演进中它也变得越来越好了。JS 有七种基础类型，分别是 Null，Undefined，Boolean，Number，String，BigInt 和 Symbol，它们都是不可变（immutable）的。最开始的时候 JS 只有前面五种基础类型，在 ES6 中引入了 Sybmol 和 BigInt。在此之前 JS 是没有整数类型的，它的 Number 类型就是浮点数，这也导致最大的精确整数只能到 2^53 - 1，在浏览器中试试下面的代码，也许你会感到很惊奇：

#+BEGIN_SRC javascript
  9007199254740991 + 2
  //9007199254740992
  // 2^53 - 1 = 9007199254740991
#+END_SRC

JS 饱受诟病的一点在于它的弱类型，正是它导致了本章开头的那些 meme 的出现。类型的自动转换当然是有规则的，但是谁愿意在写代码的时候想着这些奇形怪状的东西呢？关于 implicit type convension 这里有篇不错的[[https://dev.to/antonmelnyk/understanding-javascript-type-conversions-43n][文章]]可以看看。一些新的语言，比如 TypeScript 和 Rescript 都在类型上做出了非常不错的改进。

最开始的时候 JS 只有全局作用域和函数作用域。函数作用域即函数体内定义的变量只能在函数内部使用。在 ES6 中 JS 引入了块作用域，通过 let 和 const 关键字来 *声明* 块变量，下面的例子可以说明这三种作用域。和作用域相关的东西我们还可以扯到闭包，实际上现在拿闭包或者 closure 作为搜索关键字的话搜到的东西十有八九和 JS 有关。 /Closures are poor man's objects and vice versa. HaHa./

#+BEGIN_SRC javascript
  var a = 1

  (function (b, c) {
      var d = a + b
      {
	  let a = 2
	  var e = c + a
      }
      var f = e + 1
      console.log([d, e, f])
  })(1, 1)

  // [2, 3, 4]
#+END_SRC

上面我们也提到了 JS 从 Scheme 借鉴来了 first class function，这对于函数式编程来说是个非常重要的特性，函数可以作为数据意味着我们可以很容易地使用函数来做一些抽象，对于熟悉函数式编程的你相信不会太陌生。ES6 中引入了箭头函数，它可以让我们更方便地编写匿名函数，比如 =x=>x= 。它与使用 =function= 关键字的匿名函数还是有一定的区别，具体可以参考[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions][文档]]。

最让我觉得 JS 像 Scheme 的地方还是它的尾调用优化（tail-call optimization）。ES6 中引入了尾递归优化，但是大部分 JS 实现都没有支持它（不过在 JavaScriptCore 中还是提供了支持），这是因为尾递归优化不利于调试，原本应该堆栈溢出的程序可能变成死循环了。

接下来我们说说对象和 OOP 相关的东西。就算你没有写过 JS，你也应该使用过 JSON 格式的文件来写配置或者存数据，JSON 即 JavaScript Object Notation，翻译成中文就是 JavaScript *对象* 记号（笑）。对象是 JS 中的唯一一种引用类型，具有属性（properties）和方法（methods）。在 JS 中除上面的七种基础类型外的所有东西都是对象，就连数组和函数（稍微特殊一点，有 ~typeof (x=>x) === 'function'~ ）也是对象（但 ~typeof null === 'object'~ ，这是个历史错误）。

JS 的对象类似于关联数组（associate array），对象就是一个个键值对构成的集合。其中的键的类型可以是 String 和 Symbol，值则可以是任意类型。关于 JS 中的 OOP 我们留到下一节来详细介绍，它稍微有点小复杂（按 MDN 上的说法是有点 /abstruse/ ），现在就先介绍一些基础的对象操作吧。

- 可以使用 ={...}= 表达式（object initializers）， =new Object()= ，构造函数， =Object.create()= ， =Object.fromEntries()= 等来创建对象
- 可以使用 simple dot-notation 来访问对象中的属性和方法，就像 =a.b= ，也可以使用属性访问器（property accessors） =[]= 。使用 =Object.keys()= ， =Object.values()= 和 =Object.entries()= 分别可以获得由对象的键，值和键值对数组组成的数组
- 使用 =a.b = c= 即可为对象 =a= 添加或修改键值对 =b,c= ，也可使用 =Object.assign()= 将一个或多个对象所有可枚举（enumerable）的属性复制到目标对象
- 使用 =delete= 可以删除对象中的某一键值对，比如 =delete a.b=

上面列出的操作并不全，详情可参考 MDN 上的 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects][Working with Object]] 和 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object][Object]]。下面我们给出一些示例代码：

#+BEGIN_SRC javascript
  let yya = {
      a: 7,
      inca() {this.a += 1; return this.a},
      deca() {this.a -= 1; return this.a}
  }

  let yyb = new Object()
  yyb.a = 7
  yyb.inca = function(){this.a += 1; return this.a}
  yyb.deca = function(){this.a -= 1; return this.a}

  let yyc = Object.fromEntries([['a', 7],
				['inca', function(){this.a += 1; return this.a}],
				['deca', function(){this.a -= 1; return this.a}]])

  console.log([yya, yyb, yyc])
  //0: {a: 7, inca: ƒ, deca: ƒ}
  //1: {a: 7, inca: ƒ, deca: ƒ}
  //2: {a: 7, inca: ƒ, deca: ƒ}

  console.log([yya.inca(), yyb['inca'](), yyc.deca()])
  // [8, 8, 6]

  let yyd = Object.create({inca(){this.a+=1; return this.a}})
  yyd.a = 1
  console.log(yyd.inca())
  // 2

  let yye = {1:2, 2:3, 3:4, 4:5, 5:6}
  console.log(Object.keys(yye))
  console.log(Object.values(yye))
  console.log(Object.entries(yye))
  // ['1', '2', '3', '4', '5']
  // [2, 3, 4, 5, 6]
  // [['1', 2], ['2', 3], ['3', 4], ['4', 5], ['5', 6]]

  let yyf = new Object()
  Object.assign(yyf, yye)
  console.log(yyf)
  // {1: 2, 2: 3, 3: 4, 4: 5, 5: 6}

  yyf['1'] = 1; yyf['2'] = 2; yyf['3'] = 3; yyf['4'] = 4; yyf['5'] = 5;
  console.log(yyf)
  // {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}

  delete yyf['1']
  console.log(Object.keys(yyf))
  // ['2', '3', '4', '5']
#+END_SRC

这里提一嘴 =this= ，在 JS 中它是一个关键字，在不同的上下文下有不同的意义。本文中我不会对它做太多说明，用到的地方应该能够一眼看懂，看不懂的话可以参考 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this][this]]。

虽然基础类型不是对象，但是它们可以表现得像个对象，在对基础类型访问属性或调用方法时，JS 会自动将它“放入”一个对象中，然后来调用对应的方法或获取对应的属性。对于数字、字符串和布尔值，我们可以通过显式创建对象的方法来获取包裹基础类型的对象，不过一般最好不要这样做。

#+BEGIN_SRC javascript
  (() => {
      let num = 1
      let str = "hello"
      let bar = true m
      let f = () => console.log([typeof num, typeof str, typeof bar])
      f()
      num = Number(1)
      str = String("hello")
      bar = Boolean(true)
      f()
      num = new Number(1)
      str = new String("hello")
      bar = new Boolean(true)
      f()
  })()
  // ['number', 'string', 'boolean']
  // ['number', 'string', 'boolean']
  // ['object', 'object', 'object']
#+END_SRC

=null= 和 =undefined= 自不必多说，我们仅仅使用它们的值，也用不着为它们构造对象。但是为什么 =BigInt= 和 =Symbol= 不能使用 =new= 来创建对于的对象呢？在 MDN 的 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol][Symbol]] 页面是这样说的：

#+BEGIN_QUOTE
/This prevents authors from creating an explicit Symbol wrapper object instead of a new Symbol value and might be surprising as creating explicit wrapper objects around primitive data types is generally possible/
#+END_QUOTE

上面这句话的大意是使用 =new= 报错的话可以让代码作者意识到这里使用了对象而不是基础类型 Symbol。看来标准就是不想让用户创建显式的 wrapped object， =BigInt= 不能用 =new= 应该也是这个原因，关于 =BigInt= 为啥不能用我在网上只搜到了一条[[https://github.com/tc39/proposal-bigint/issues/161][讨论]]。总之，将基础类型的 wrap 交给 JS 吧，它会做的更好更快。

和一般的基于类的 OOP 不同，JS 的 OOP 是基于原型的（Class based VS Prototype based），在 JS 中并没有真正的类（指 OOP 语言的那种），它们是使用函数“模拟”出来的（直到 ES6 中才引入了 class 关键字来声明类，但是底层还是原型链那一套）。我本想在这里简单介绍下原型链完事，但写到一半我想到何不直接对 OOP 做个总结呢？所以 JS 的 OOP 部分我们留到下一大节。

我们在上面完成了对 JS 类型的简单介绍，这也是这一小节的大部分内容了。下面我们略过一些基础的操作符、控制流和错误处理语法，以及类似数学函数、日期和正则相关的标准库（标准对象），转而关注一下 JS 中的异步操作、generator 和模块管理。 =Promise= 异步算是 JS 的一大特色。

同步和异步这两个词可以用在很多地方，这里我们只关注同步调用和异步调用。同步调用指的是调用后 caller 需要等待 callee 返回才能继续执行，异步调用则不然， caller 调用后无需等待即可继续执行，callee 的返回一般由 callback 函数而不是 caller 处理。下面的例子可以说明同步和异步的区别，由于 js 里面没有 sleep 函数，这里用 Python 举个例子：

#+BEGIN_SRC python
  from time import sleep, time
  import asyncio

  def f_delay_number_sync(seconds, number):
      sleep(seconds)
      print(number)

  async def f_delay_number_async(seconds, number):
      await asyncio.sleep(seconds)
      print(number)

  t = time()
  def get_time(n):
      global t
      print(f"No.{n} finished at {str(time() - t)}")

  def run_sync():
      print('sync:')
      f_delay_number_sync(1, 1)
      f_delay_number_sync(1, 2)
      f_delay_number_sync(1, 3)
      get_time(1)

  async def run_async():
      print('async:')
      t1 = asyncio.create_task(f_delay_number_async(1, 4))
      t2 = asyncio.create_task(f_delay_number_async(2, 5))
      t3 = asyncio.create_task(f_delay_number_async(3, 6))
      await t1
      await t2
      await t3
      get_time(2)

  run_sync()
  asyncio.run(run_async())

  # sync:
  # 1
  # 2
  # 3
  # No.1 finished at 3.0292680263519287
  # async:
  # 4
  # 5
  # 6
  # No.2 finished at 6.035355806350708
#+END_SRC

可见同步执行和异步执行用时都差不多是三秒，如果异步改同步的话用时应该是六秒。下面是使用 JS 完成的异步调用示例：

#+BEGIN_SRC javascript
  let t = Date.parse(new Date())

  setTimeout(()=> console.log(Date.parse(new Date()) - t), 1000)
  setTimeout(()=> console.log(Date.parse(new Date()) - t), 2000)
  setTimeout(()=> console.log(Date.parse(new Date()) - t), 3000)

  // 1000
  // 2000
  // 3000
#+END_SRC

JS 中没有同步的 sleep 函数并不意味着我们不能用 =setTimeout= 来得到同步的效果，我们可以把回调函数嵌套起来达到同步的效果，就像这样：

#+BEGIN_SRC javascript
  let t = Date.parse(new Date())
  setTimeout(() => {
      console.log([1, Date.parse(new Date()) - t])
      setTimeout(() => {
	  console.log([2, Date.parse(new Date()) - t])
	  setTimeout(() => {
	      console.log([3, Date.parse(new Date()) - t])
	  }, 3000)
      }, 2000)
  }, 1000)

  // [1, 1000]
  // [2, 3000]
  // [3, 6000]
#+END_SRC

再多套几层的话，我们就得到了所谓的回调地狱。Promise 就是为了处理需要 *按顺序进行的异步调用* 而出现的，嵌套的回调函数一来可读性比较差，二来回调层数一多其中的错误处理也就复杂了起来。Promise 在这两个方面做出了改进。这里有篇不错的文章：[[https://juejin.cn/post/6844903636737196045][Promise到底解决了什么问题]]，在 Promise 使用上我就不班门弄斧了，它的详细用法可以参考 MDN 上的 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises][Using Promises]]。下面我们用 Promise 把上面的 =setTimeout= 修改的更好看一点吧：

#+BEGIN_SRC javascript
  var t = Date.parse(new Date())

  const f = function(num, time) {
      return new Promise((resolve, reject) => {
	  setTimeout(() => {
	      console.log([num, Date.parse(new Date()) - t])
	      resolve()
	  }, time)
      })
  }

  f(1, 1000)
      .then(() => f(2, 2000))
      .then(() => f(3, 3000))

  // [1, 1000]
  // [2, 3000]
  // [3, 6000]
#+END_SRC

在 ES6 中还引入了 async/await 关键字，在 JS 中它就是 Promise 的语法糖，下面的代码功能上和上面一致：

#+BEGIN_SRC javascript
  var t = Date.parse(new Date())
  const f = function(num, time) {
      return new Promise((resolve, reject) => {
	  setTimeout(() => {
	      console.log([num, Date.parse(new Date()) - t])
	      resolve()
	  }, time)
      })
  }

  async function foo(num, time) {
      await f(1, 1000)
      await f(2, 2000)
      await f(3, 3000)
  }

  foo()

  // [1, 1000]
  // [2, 3000]
  // [3, 5000]
#+END_SRC

接下来简单介绍下 JS 中的 generator，如果你使用过 Python 等支持迭代器的语言，那么应该会很熟悉：

#+BEGIN_SRC javascript
  const f = function* fib() {
      let a = 0
      let b = 1
      let c = 0
      while (true) {
	  c = b
	  b = a + b
	  a = c
	  yield a
      }
  }
  let g = f()

  for (var i = 0; i < 10; i++) {
      console.log(g.next().value)
  }

  // 1
  // 2
  // 3
  // 5
  // 8
  // 13
  // 21
  // 34
  // 55
#+END_SRC

JS 的模块功能出现时间比较晚，在 ES6 才引入，这是因为 JS 一开始并不需要处理比较复杂的任务，所以代码也就比较短小。如果你用过提供模块功能的语言，那应该对 JS 的模块功能会感到比较熟悉。MDN 上的 [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules][Modules]] 讲的已经很清楚了，而且模块的使用上也比较偏实践，这里就不做介绍了。

最后的最后再说下 JS 中的元编程功能。如果没有看 MDN 文档的话，我都不知道 JS 还有这功能。因此我没用过这里什么都不说是最好的，去看看 MDN 和其他教程吧。 +（草，这不是什么也没说吗）+

** 作为技术的 JavaScript

这一小节的标题是“作为技术的 JS”，起这个名字是为了和上一节保持格式一致，“作为技术的”这个短语似乎有点指意不明，是指 JS 本身的实现呢还是指应用呢？对于前者我是一点也不了解，后者还能找些资料说一说。编程技术这个词我没找到一个足够可信的释义，这里只能参考百度百科，解释为“借助计算机达到某一目的或解决某个问题的技术”。那么，一门语言的技术，比如“Java 技术”，“C++ 技术” 等指的应该是使用某种编程语言来完成一项或一类任务的方法或工具吧。

JS 开始是作为浏览器页面的脚本语言，作用是为页面提供动态功能，随着 nodejs 等技术的出现它也不再限于浏览器，被用在了许多非浏览器环境中。就算你没写过代码，如果听过一些程序员笑话的话也应该知道“前端”和“后端”两个词，这一节我们就这两大方向简单介绍一下 JS 的应用范围，以及一些流行或曾经流行过的 JS 技术。我们首先从前端（frontend）和后端（backend）的释义开始说起。




** 一些补充


- https://juejin.cn/post/6978524109336657956
- https://evertpot.com/ecmascript-4-the-missing-version/
- https://news.ycombinator.com/item?id=6068360
- https://juejin.cn/post/6844903926932701198
- https://dev.to/mayankav/is-everything-in-javascript-an-object-1alg
- https://towardsdatascience.com/everything-about-javascript-object-part-1-854025d71fea
- https://www.w3schools.com/js/js_objects.asp
- https://www.w3schools.com/js/default.asp
- http://vanilla-js.com/
- https://github.com/tamzinblake/js3-mode
- https://github.com/mooz/js2-mode
- https://es6.ruanyifeng.com/#docs/let
- https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/


* 提一嘴 OOP

在简单介绍 JS 的 OOP 之前咱还是介绍下啥是 OOP 先，毕竟我没怎么写过面向对象的代码。你大可认为写这篇文章的时候我是个 OOP 白痴，然后跳过下一节中的大放厥词。我写这段的目的是给 *自己* 找一个说得过去的 OOP 认识。

如果你和我一样是从 C 开始学的编程，那么接触到的第一门所谓的 OOP 语言应该是 C++。很可惜的是我在学习 C++ 这件事上屡战屡败，到现在都没有看完 C++ Primer 第五版，我可是从二〇一九年就开始尝试了（笑）。不知道是不是学不会 C++ 这件事让我有点面向对象恐惧症，我现在还没有系统地学过任何的主流 OOP 语言，我的 Python 水平仅有读完官方 Tutorial 的水平，而且不会写类，我还尝试过 Java，但没写几行就放弃了。现在是看到 =class= 关键字我就不是很舒服，PTSD 了属于是。借着学习 emacs 和 javascript 的机会，看看这一次能否再次认识一下 OOP，让我摆脱掉 OOP PTSD。这一节我会参考一些资料，介绍一下 OOP 三要素（封装继承多态）出现之前的 OOP，看看最开始的 OOP 是什么样的。

和 JS 一样，我对 OOP 的认识约等于零，而且我也没有参加软件开发的经验，也就是说如果你在下文中发现了什么不对劲的地方的话，你很可能是对的。由于时间和能力问题，我不可能完成对整个 OO 范式发展的描述和分析，这大概够写一堆书的。OO 背后涉及到了很多计算机理论的知识，下文我会简单介绍一下粗浅的内容。原本我是准备在使用过市面上主流的 OOP 语言后再专门写一篇总结性的文章，但是实在太费事了，遂放弃，咱还是放弃整体求局部吧，一个足够简单的模型也许更易于认识，就像 λ 一样。在下文中我会使用 C++/CL/Elisp/Racket 作为基于类的 OO 代表，与 JS 作为基于原型的 OO 代表来举例。如果你不太了解 Lisp 系语言的话，C++ 代码应该比较容易懂。

最后声明一下，由于个人原因，我对于 OO 的态度并不怎么正面，所以下面内容整体可能对 OO 呈负面态度，当然我会尽量保证引用内容的准确性并给出来源。如果文中内容令你不快，可跳至下一节或 =Alt+F4= 或右划，或者给出你的观点。

** OOP 简史

OOP 的全称是 Object Oriented Programming，即面向对象编程，也叫物件导向程式设计，强调将程序看作不同对象的调用交互过程。按我的理解，将程序看作对象的交互就是要在对象与对象之间划分出边界来，让每个对象负责好它自己的那一部分，这有点像社会中的人，只负责自己的吃喝拉撒。所以 *封装* 就是 OOP 的一大特点，作为对象的你把握好三寄吧原则就好：你寄吧谁啊，我寄吧谁啊，他寄吧谁啊。既然有了边界，那么两对象之间也需要交流机制，通过某种标准的方式来进行交互，这在 OOP 中被称为 *消息* 。 *封装* 与 *消息* 就是我对 OOP 的认识了，至于封装继承多态抽象啥的去他的吧。就这么看的话，咱写 OOP 的代码并不需要一门声称支持 OOP 的语言，下面我们用闭包来捏个计数器对象玩玩：

#+BEGIN_SRC javascript
    let Ytimer = function (init_value) {
	let val = init_value;
	this.get = function () { return val; };
	this.inc = function () { val = val + 1; return val; };
	this.dec = function () { val = val - 1; return val; };
    }

    let at = new Ytimer(10)

    at.get() // 10
    at.inc() // 11
    at.dec() // 10
#+END_SRC

上面的对象提供了三个方法，分别是获取计数，增加计数和减少计数，调用这些方法就像是发消息给这个对象，同时你也没有除 =get= 外的其他方法来获得当前计数器的值，这就非常的封装，非常的 OO。使用消息来达到完成某种动作的目的就意味着 *抽象* ，发号施令者把简单的消息告诉了实施者，再由实施者来完成，这也算是由少（消息）到多（动作）的过程，嗯，这很抽象。

我们上面拿函数来实现了消息机制，看上去比函数抽象也没高级到哪里去，这就要看和谁相比了：对 C 这种不允许匿名函数的语言来说，要想拿函数名字当作消息名有点困难，如果我们想给获取一堆对象的“长度”，那我们要给每个.


* 后记

个人对历史
时间
