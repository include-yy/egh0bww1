#+TITLE: ä¸€ä¸ª case-lambda çš„ CL/Elisp å®žçŽ°ï¼Œä»¥åŠå¯¹å®ƒçš„åˆ†æžå’Œæ”¹è¿›
#+DATE: [2025-11-08 Sat 16:08]--[2025-11-09 Sun 18:13]
#+FILETAGS: lisp
#+DESCRIPTION: æŸä¸ªæœ‹å‹é€šè¿‡ä¸€æ®µä»£ç å±•ç¤ºäº†ä»–å¯¹æ¨¡å¼è¯†åˆ«çš„ç†è§£ï¼Œä¹Ÿè®¸è¿™éœ€è¦ä¸€ç‚¹æ”¹è¿›ã€‚

æœ¬æ–‡æ˜¯å¯¹ä¸€æ®µ =case-lambda= ([[https://srfi.schemers.org/srfi-16/srfi-16.html][SRFI-16]]) å®žçŽ°ä»£ç çš„åˆ†æžä¸Žæ”¹è¿›ã€‚è¿™ä¸€ä»£ç æ¥è‡ªæˆ‘å’Œæœ‹å‹å¯¹ PMï¼ˆPattern Matchingï¼Œæ¨¡å¼åŒ¹é…ï¼‰çš„ä¸€äº›è®¨è®ºï¼Œä»–éšåŽå®žçŽ°äº† SRFI-16ï¼Œå¹¶ç»™å‡ºäº†ä¸€ä¸ªå®žçŽ°ï¼ŒæŸç§æ„ä¹‰ä¸Šæ¥è¯´è¿™ä¸ªå®žçŽ°å¾ˆæœ‰è¶£ï¼Œä½†å¾ˆå¯æƒœä¸æ€Žä¹ˆå¯è¯»ã€‚æ­£å¥½æœ€è¿‘åœ¨å­¦ä¹ è½¯ä»¶æµ‹è¯•åŸºç¡€çŸ¥è¯†ï¼Œæ—¢ç„¶è‰¯å¥½çš„å¯è¯»æ€§æœ‰åˆ©äºŽåšé™æ€æµ‹è¯•ï¼Œä¹Ÿè®¸æˆ‘å¯ä»¥è¯•ç€æ”¹æ”¹è¿™ä¸ªä»£ç ï¼Œä½¿ç”¨æ­£ç¡®çš„å®žè·µæ–¹å¼æé«˜ä¸€ä¸‹å¯è¯»æ€§ã€‚

å¦‚æžœè®©è¯»è€…ç›´æŽ¥å¼€å§‹çœ‹è¿™ä¸ªä»£ç ä¼°è®¡è¿žæ€è·¯éƒ½æ‘¸ä¸æ¸…æ¥šï¼Œæˆ‘ä»¬å…ˆä»Ž SRFI-16 æ ‡å‡†å’Œå‚è€ƒå®žçŽ°å¼€å§‹è¯´èµ·ï¼Œå…ˆäº†è§£åŸºç¡€å®žçŽ°æ€è·¯åŽä»£ç åº”è¯¥å®¹æ˜“ç†è§£å¾ˆå¤šã€‚æŽ¥ç€æˆ‘ä»¬é€æ®µé˜…è¯»ä¸€ä¸‹è¿™ä¸ªå®žçŽ°ï¼ŒæŒ‡å‡ºå…¶ä¸­çš„ä¸€äº›é—®é¢˜ã€‚åœ¨æœ€åŽæˆ‘ä¼šç»™å‡ºæˆ‘çš„æ”¹è¿›å®žçŽ°ï¼Œä»¥åŠå¯èƒ½çš„æˆ‘çš„æœ‹å‹çš„æ”¹è¿›ã€‚

æ¥ç‚¹ bgmï¼š[[https://www.bilibili.com/video/BV13H1DBgE4A][ã€åˆéŸ³ãƒŸã‚¯ã€‘ä½•å›žã ã£ã¦ã€ãƒžãƒŒã‚«ãƒ»ãƒãƒ‹ãƒ¼ã€‘]]

* SRFI-16 åŠå…¶å‚è€ƒå®žçŽ°

#+begin_quote
CASE-LAMBDA reduces the clutter of procedures that execute different code depending on the number of arguments they were passed; it is a pattern-matching mechanism that matches on the number of arguments. CASE-LAMBDA is available in some Scheme systems.
#+end_quote

ç›¸æ¯”ä½¿ç”¨ä¸å®šå‚æ•° (variadic arguments)ï¼Œâ€‹=case-lambda= é¿å…äº†æ‰‹åŠ¨èŽ·å–å‚æ•°ä¸ªæ•°å’Œè§£åŒ…çš„è¿‡ç¨‹ï¼Œæœ‰åˆ©äºŽæé«˜ä»£ç çš„å¯è¯»æ€§ã€‚[[https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28quote._~23~25kernel%29._case-lambda%29%29][Racket æ–‡æ¡£]]ç»™å‡ºäº†ä¸‹é¢çš„ä¾‹å­ï¼š

#+begin_src racket
  (let ([f (case-lambda
             [() 10]
             [(x) x]
             [(x y) (list y x)]
             [r r])])
    (list (f)
          (f 1)
          (f 1 2)
          (f 1 2 3)))
  ;;=> '(10 1 (2 1) (1 2 3))
#+end_src

å¦‚æžœæˆ‘ä»¬æ‰‹åŠ¨å®žçŽ°ï¼Œå¯èƒ½ä¼šç»™å‡ºè¿™æ ·çš„ä»£ç ï¼š

#+begin_src racket
  (let ([f (lambda args
             (let ([len (length args)])
               (cond
                 [(= len 0) 10]
                 [(= len 1) (car args)]
                 [(= len 2) (list (second args) (first args))]
                 [else args])))])
    (list (f)
          (f 1)
          (f 1 2)
          (f 1 2 3)))
#+end_src

SRFI-16 ç»™å‡ºçš„ =case-lambda= å‚è€ƒå®žçŽ°å¦‚ä¸‹ï¼Œä½¿ç”¨äº†æ ‡å‡†çš„ =syntax-rules= å®ï¼š

#+begin_src scheme
  ;; This code is in the public domain.

  (define-syntax case-lambda
    (syntax-rules ()
      ((case-lambda)
       (lambda args
         (error "CASE-LAMBDA without any clauses.")))
      ((case-lambda 
        (?a1 ?e1 ...) 
        ?clause1 ...)
       (lambda args
         (let ((l (length args)))
           (case-lambda "CLAUSE" args l 
             (?a1 ?e1 ...)
             ?clause1 ...))))
      ((case-lambda "CLAUSE" ?args ?l 
        ((?a1 ...) ?e1 ...) 
        ?clause1 ...)
       (if (= ?l (length '(?a1 ...)))
           (apply (lambda (?a1 ...) ?e1 ...) ?args)
           (case-lambda "CLAUSE" ?args ?l 
             ?clause1 ...)))
      ((case-lambda "CLAUSE" ?args ?l
        ((?a1 . ?ar) ?e1 ...) 
        ?clause1 ...)
       (case-lambda "IMPROPER" ?args ?l 1 (?a1 . ?ar) (?ar ?e1 ...) 
         ?clause1 ...))
      ((case-lambda "CLAUSE" ?args ?l 
        (?a1 ?e1 ...)
        ?clause1 ...)
       (let ((?a1 ?args))
         ?e1 ...))
      ((case-lambda "CLAUSE" ?args ?l)
       (error "Wrong number of arguments to CASE-LAMBDA."))
      ((case-lambda "IMPROPER" ?args ?l ?k ?al ((?a1 . ?ar) ?e1 ...)
        ?clause1 ...)
       (case-lambda "IMPROPER" ?args ?l (+ ?k 1) ?al (?ar ?e1 ...) 
        ?clause1 ...))
      ((case-lambda "IMPROPER" ?args ?l ?k ?al (?ar ?e1 ...) 
        ?clause1 ...)
       (if (>= ?l ?k)
           (apply (lambda ?al ?e1 ...) ?args)
           (case-lambda "CLAUSE" ?args ?l 
             ?clause1 ...)))))
#+end_src

æ ¹æ®æ¯æ¡åˆ†æ”¯ä¸åŒçš„å‚æ•°åˆ—è¡¨æƒ…å†µï¼Œâ€‹=case-lambda= å°†å®ƒä»¬åˆ†ä¸ºä¸¤ç±»ï¼Œåˆ†åˆ«æ˜¯å›ºå®šå‚æ•°å­å¥çš„ ="CLAUSE"= å’Œå¤„ç†å¸¦ä¸å®šå‚æ•°å­å¥çš„ ="IMPROPER"=â€‹ï¼Œå‰è€…çš„å‚æ•°åˆ—è¡¨æ˜¯å¸¸è§„åˆ—è¡¨ (proper list)ï¼Œè€ŒåŽè€…æ˜¯ä¸å½“åˆ—è¡¨ (improper list, å³ CONS)ã€‚å¯¹äºŽå›ºå®šå‚æ•°çš„å­å¥ï¼Œè´Ÿè´£å±•å¼€å®ƒçš„ä»£ç å¦‚ä¸‹ï¼š

#+begin_src scheme
  ((case-lambda "CLAUSE" ?args ?l 
    ((?a1 ...) ?e1 ...) 
    ?clause1 ...)
   (if (= ?l (length '(?a1 ...)))
       (apply (lambda (?a1 ...) ?e1 ...) ?args)
       (case-lambda "CLAUSE" ?args ?l 
         ?clause1 ...)))
#+end_src


æ­¤åˆ†æ”¯ä¸­å€¼å¾—æ³¨æ„çš„æ˜¯å…¶å‚æ•°åŒ¹é…æ¨¡å¼ =(?a1 ...)=â€‹ï¼Œåœ¨ =syntax-case= ä¸­ï¼Œè¿™ç”¨äºŽåŒ¹é…ä¸€ä¸ªå¸¸è§„åˆ—è¡¨ã€‚åœ¨å±•å¼€å¼ä¸­ï¼Œè¯¥åˆ—è¡¨é•¿åº¦ä¼šä¸Žå‡½æ•°æŽ¥å—çš„å‚æ•°é•¿åº¦è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥åŒ¹é…åˆ™æ‰§è¡Œå¯¹åº”è¡¨è¾¾å¼ï¼Œå¦åˆ™è¿›å…¥ä¸‹ä¸€ä¸ªå­å¥ã€‚åœ¨è¿™ä¸€è§„åˆ™çš„ä¸‹é¢å°±æ˜¯ä»Ž ="CLAUSE"= å‘ ="IMPROPER"= çš„è½¬æ¢è¿‡ç¨‹ï¼Œå¦‚æžœ =(?a1 ...)= åŒ¹é…å¤±è´¥ï¼Œåˆ™è¯´æ˜Žå‚æ•°åˆ—è¡¨ä¸æ˜¯ä¸€ä¸ªå¸¸è§„åˆ—è¡¨ï¼ˆå³ä¸ä»¥ =nil= ç»“å°¾ï¼‰ï¼Œè€Œæ˜¯å¸¦æœ‰å‰©ä½™å‚æ•°çš„ä¸å½“åˆ—è¡¨ï¼š

#+begin_src scheme
  ((case-lambda "CLAUSE" ?args ?l
    ((?a1 . ?ar) ?e1 ...) 
    ?clause1 ...)
   (case-lambda "IMPROPER" ?args ?l 1 (?a1 . ?ar) (?ar ?e1 ...) 
     ?clause1 ...))
#+end_src

æ­¤æ—¶ï¼Œå®ƒä¼šè½å…¥ =((?a1 . ?ar) ?e1 ...)= è§„åˆ™ï¼Œæ­¤å¤„çš„ =(?a1 . ?ar)= è¡¨ç¤ºåŒ¹é…ä¸€ä¸ª CONSï¼Œâ€‹=?a1= åŒ¹é…ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œâ€‹=?ar= åŒ¹é…å‰©ä½™å†…å®¹ã€‚å› ä¸ºè¿™ä¹Ÿä¼šåŒ¹é…æ™®é€šçš„åˆ—è¡¨ï¼Œæ‰€ä»¥å®ƒå¿…é¡»ä½äºŽä¸Šä¸€åˆ†æ”¯çš„ä¸‹é¢ã€‚ä»¥ =((a b . c) e)= è¿™ä¸€å­å¥ä¸ºä¾‹ï¼Œåœ¨è¿™ä¸€è½¬æ¢åŽæˆ‘ä»¬ä¼šå¾—åˆ° =(case-lambda "IMPROPER" ?args ?l 1 (a b . c) ((b . c) e) ...)=â€‹ã€‚è¿™é‡Œå‡ºçŽ°çš„æ•°å­— 1 å’ŒåŽ»æŽ‰ =?a1= åŽå¾—åˆ°çš„ =(b . c)= ä¸»è¦æ˜¯ç”¨äºŽé€’å½’æ‰¾åˆ°å›ºå®šå‚æ•°ä¸ªæ•°çš„è¿‡ç¨‹ï¼Œå…·ä½“ç”± =case-lambda= çš„æœ€åŽä¸¤ä¸ªåˆ†æ”¯æ¥å®žçŽ°ï¼š

#+begin_src scheme
  ((case-lambda "IMPROPER" ?args ?l ?k ?al ((?a1 . ?ar) ?e1 ...)
    ?clause1 ...)
   (case-lambda "IMPROPER" ?args ?l (+ ?k 1) ?al (?ar ?e1 ...) 
    ?clause1 ...))
  ((case-lambda "IMPROPER" ?args ?l ?k ?al (?ar ?e1 ...) 
    ?clause1 ...)
   (if (>= ?l ?k)
       (apply (lambda ?al ?e1 ...) ?args)
       (case-lambda "CLAUSE" ?args ?l 
         ?clause1 ...)))
#+end_src

å¯ä»¥çœ‹åˆ°ï¼Œä¸Šé¢ä»£ç ä¸­çš„ç¬¬ä¸€ä¸ªè§„åˆ™æ˜¯é€’å½’çš„ï¼Œåªè¦ä¼ å…¥çš„æ¨¡å¼èƒ½åŒ¹é… =((?a1 . ?ar) ?e1 ...)= å½¢å¼ï¼Œå®ƒå°±ä¼šç»§ç»­è¿­ä»£å¹¶ä½¿è®¡æ•°å™¨ =?k= åŠ ä¸€ã€‚å½“ä¼ å…¥çš„æ¨¡å¼ä¸å†åŒ¹é…æ­¤å½¢å¼æ—¶ï¼Œå®ƒå°±ä¼šè½å…¥ç¬¬äºŒæ¡è§„åˆ™ã€‚æ­¤æ—¶ =?k= æ­£ç¡®åœ°æŒæœ‰å›ºå®šå‚æ•°çš„ä¸ªæ•°ï¼Œå®ä¼šç”Ÿæˆæœ€ç»ˆçš„ =if= ç»“æž„ï¼Œå¹¶ç»§ç»­å±•å¼€å¯èƒ½çš„å‰©ä½™å­å¥ã€‚

æœ€åŽï¼Œæ˜¯åªå¸¦ä¸€ä¸ªä¸å®šå‚æ•°çš„å½¢å¼ï¼Œä»£ç ä¹Ÿå¾ˆç®€å•ï¼š

#+begin_src scheme
  ((case-lambda "CLAUSE" ?args ?l 
        (?a1 ?e1 ...)
        ?clause1 ...)
       (let ((?a1 ?args))
         ?e1 ...))
#+end_src

å½“ç„¶æˆ‘ç•¥è¿‡äº†é”™è¯¯å½¢å¼ï¼Œè¿™äº›æ¯”è¾ƒå®¹æ˜“ç†è§£ã€‚ä¸‹é¢æ˜¯åœ¨ Racket ä¸­ä½¿ç”¨ SRFI-16 çš„å®žçŽ°å¯¹æˆ‘ä»¬åœ¨å¼€å¤´ç»™å‡ºçš„ä¾‹å­è¿›è¡Œå±•å¼€çš„ç»“æžœï¼š

#+begin_src scheme
  (expand '(case-lambda
            [() 10]
            [(x) x]
            [(x y) (list y x)]
            [r r]))

  '(#%expression
    (lambda args
      (let-values (((l) (#%app length args)))
        (if (#%app = l (#%app length '()))
          (#%app apply (lambda () '10) args)
          (if (#%app = l (#%app length '(x)))
            (#%app apply (lambda (x) x) args)
            (if (#%app = l (#%app length '(x y)))
              (#%app apply (lambda (x y) (#%app list y x)) args)
              (let-values (((r) args)) r)))))))
#+end_src

ä¸‹é¢è¿™ä¸ªä¾‹å­å¯ä»¥è¯´æ˜Žå®ƒå¯¹å¸¦æœ‰å‰©ä½™å‚æ•°çš„è¡¨è¾¾å¼çš„å¤„ç†è¿‡ç¨‹ï¼š

#+begin_src scheme
  (syntax->datum (expand '(case-lambda
                           [(x) (+ x 1)]
                           [(x y . z) (+ x y (car z))])))

  '(#%expression
    (lambda args
      (let-values (((l) (#%app length args)))
        (if (#%app = l (#%app length '(x)))
          (#%app apply (lambda (x) (#%app + x '1)) args)
          (if (#%app >= l (#%app + '1 '1))
            (#%app apply (lambda (x y . z) (#%app + x y (#%app car z))) args)
            (#%app error '"Wrong number of arguments to CASE-LAMBDA."))))))
#+end_src

** å¯èƒ½çš„ä¼˜åŒ–

#+begin_quote
While CASE-LAMBDA can be implemented as a macro using only facilities available in R5RS Scheme, it admits considerable implementation-specific optimization.
#+end_quote

ç”±äºŽ =syntax-rules= å¹¶ä¸ä¼šåšâ€‹*å±•å¼€æ—¶è®¡ç®—*â€‹è€Œåªæœ‰â€‹*å±•å¼€æ—¶å˜æ¢*â€‹ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ä¸Šé¢çš„æŸäº›èƒ½åœ¨å±•å¼€æ—¶å°±å®Œæˆçš„ä¼˜åŒ–æ²¡æœ‰åšï¼Œæ¯”å¦‚å¸¸æ•°ç›¸åŠ å’Œæ±‚å¸¸é‡åˆ—è¡¨çš„é•¿åº¦ï¼ˆå½“ç„¶ï¼Œä¸€ä¸ªæ­£å¸¸çš„ç¼–è¯‘å™¨ä¼šå®Œæˆå¸¸é‡æŠ˜å ä¼˜åŒ–ï¼‰ã€‚

ä¸è¿‡ï¼ŒçœŸæ­£çš„å¼€é”€ç“¶é¢ˆå¯èƒ½æ˜¯å‚è€ƒå®žçŽ°ä¸­çš„è¿è¡Œæ—¶åˆ†æ´¾ï¼ŒSRFI-16 å®žçŽ°ä¸­éœ€è¦é€šè¿‡ =length= æ£€æŸ¥å‚æ•°åˆ—è¡¨çš„é•¿åº¦ç„¶åŽé€šè¿‡åµŒå¥— =if= æ‰¾åˆ°å¯¹åº”çš„å­å¥ï¼Œè¿™å’Œæˆ‘ä»¬æ‰‹å†™åŸºæœ¬ä¸Šæ²¡ä»€ä¹ˆåŒºåˆ«ã€‚å¦‚æžœ =case-lambda= è¢«åŽŸç”Ÿå®žçŽ°ï¼Œå‚æ•°ä¸ªæ•°çš„èŽ·å–å¯èƒ½å°±ä¸æ˜¯é€šè¿‡æ±‚å–åˆ—è¡¨çš„é•¿åº¦è€Œæ˜¯èŽ·å–æ ˆä¸Šçš„å‚æ•°æ•°é‡ç„¶åŽç›´æŽ¥è·³è½¬åˆ°å¯¹åº”å­å¥çš„ä»£ç å—ã€‚ä¸è¿‡æˆ‘ä¸å¤ªäº†è§£ Racket çš„æºä»£ç ï¼Œä¸å¤ªæ¸…æ¥š =case-lambda= çš„å…·ä½“å®žçŽ°ã€‚

é™¤æ­¤ä¹‹å¤–ï¼ŒSRFI-16 çš„å‚è€ƒå®žçŽ°æ–¹å¼è¿˜å†³å®šäº†å®ƒçš„åŒ¹é…è¯­ä¹‰ã€‚ç”±äºŽå®ƒæœ¬è´¨ä¸Šæ˜¯é€’å½’åœ°å±•å¼€ä¸ºä¸€ä¸ªåµŒå¥—çš„ =if= ç»“æž„ï¼Œå› æ­¤å¯¹äºŽå…·æœ‰ç›¸åŒä¸ªæ•°çš„å­å¥ï¼Œæ€»æ˜¯æœ€å…ˆå‡ºçŽ°çš„é‚£ä¸€ä¸ªä¼˜å…ˆã€‚å¦‚æžœæˆ‘æ˜¯åŽŸç”Ÿå®žçŽ°è€…çš„è¯å¯èƒ½ä¼šå¯¹è¿™æ ·çš„æƒ…å†µç»™å‡ºè­¦å‘Šã€‚ä»¥ä¸‹æ˜¯ Racket ä¸­å…·æœ‰ç›¸åŒæ•°é‡çš„å‚æ•°æ—¶ =case-lambda= çš„è¡¨çŽ°ï¼š

#+begin_src racket
  ((case-lambda [(a) a] [(b) (+ b 1)]) 1)
  ;;=> 1
#+end_src

* ä¸€ç§ =case-lambda= å®žçŽ°

ä¸‹é¢å°±æ˜¯æˆ‘çš„æœ‹å‹çš„å®žçŽ°äº†ï¼Œè¯»è€…å¦‚æžœæ„Ÿå…´è¶£å¯ä»¥ç®€å•çœ‹ä¸€éï¼Œä½†æˆ‘ä¸å¤ªå»ºè®®è¿‡äºŽæ·±å…¥äº†ï¼Œæ²¡å¿…è¦å†æŠŠæˆ‘ç”¨æŽ‰çš„æ—¶é—´å†ç”¨ä¸€éã€‚

:code:
#+begin_src lisp
  (defun case-lambda--pure-list-p (x)
    (do ((x x (cdr x)))
        ((not (consp x)) (null x))))

  (defmacro case-lambda--n-regular (x)
    `(caar ,x))
  (defmacro case-lambda--restp (x)
    `(cdar ,x))
  (defmacro case-lambda--restvar (x)
    `(cdar ,x))
  (defmacro case-lambda--arglist-body (x)
    `(cdr ,x))
  (defmacro case-lambda--arglist (x)
    `(car (case-lambda--arglist-body ,x)))
  (defmacro case-lambda--body (x)
    `(cdr (case-lambda--arglist-body ,x)))
  (defun case-lambda--make-clause (n-regular restvar arglist body)
    (cons (cons n-regular restvar) (cons arglist body)))

  (defun case-lambda--analyze (clauses)
    "convert clauses litteral to internal structure"
    (let ((res nil))
      (dolist (c clauses (nreverse res))
        (or (consp c)
            (case-lambda--pure-list-p c)
            (case-lambda--pure-list-p (car c))
          (error "Bad case-lambda clauses"))
        (let* ((arglist (car c))
               (restp (member '&rest arglist))
               (len-after-rest (and restp (length restp)))
               (n-regular (if (not restp)
                            (length arglist)
                            (- (length arglist) len-after-rest))))
          (and restp (/= 2 len-after-rest)
            (error "Bad case-lambda clauses"))
          (push (case-lambda--make-clause
                  n-regular (cadr restp) (cl-subseq arglist 0 n-regular) (cdr c))
                res)))))

  (defun case-lambda--remove-unreachable (clauses)
    "remove unreachable clauses and return reversed result"
    (let ((res nil)
          (max-n-regular -1)
          (restp nil))
      (do ((cs clauses (cdr cs)))
          ((null cs) res)
        (let ((c (car cs)))
          (or restp
            (cond ((case-lambda--restp c)
                   (setq restp t)
                   (push c res))
                  ((> (case-lambda--n-regular c) max-n-regular)
                   (setq max-n-regular (case-lambda--n-regular c))
                   (push c res))))))))

  (defmacro case-lambda--build-bind-if-tree ()
    ;; only used in case-lambda, rely on side effect
    ;; don't ever edit this unless understanding how is it going
    `(let ((n-regular (case-lambda--n-regular c))
           (nc-n-regular (if nextc (case-lambda--n-regular nextc) 0)))
       (do ((i (- n-regular 1) (- i 1)))
           ((< i nc-n-regular))
         (setq resform
           `(if (null ,input)
              ,(if (= i (- n-regular 1))
                 `(let (,@(cl-mapcar #'list (case-lambda--arglist c) regular-tmps))
                    ,@(case-lambda--body c))
                 error-form)
              ,resform))
         (when (and restp (= i rest-at))
            (setq resform
             `(let ((,rest-var ,input))
                ,resform)))
         (setq resform
           `(let ((,(nth i regular-tmps) (car ,input)))
              (setq ,input (cdr ,input))
              ,resform))
         (when (and restp (<= i rest-at))
           (setq error-form '(error "case-lambda matching failure"))))))

  (defun case-lambda--main-pattern (clauses)
    ;; don't ever edit this unless understanding how is it going
    ;; note that clauses is current reversed
    (let* ((restp (case-lambda--restp (car clauses)))
           (rest-clause (car clauses))
           (rest-clause-n-regular
             (and restp (case-lambda--n-regular rest-clause)))
           (first-clause-with-only-regulars-n-regular
             (if restp (case-lambda--n-regular (cadr clauses))
                       (case-lambda--n-regular (car clauses))))
           (max-n-regular
             (if restp
               (max rest-clause-n-regular
                    first-clause-with-only-regulars-n-regular)
               first-clause-with-only-regulars-n-regular))
           (regular-tmps
             (let ((res nil))
               (dotimes (i max-n-regular res)
                 (push (gensym) res))))
           (rest-var (and restp (case-lambda--restvar rest-clause)))
           (input (gensym))
           (rest-at (and restp (- rest-clause-n-regular 1)))
           (rest-clause-form 
             `(let (,@(cl-mapcar #'list (case-lambda--arglist rest-clause)
                                   regular-tmps)
                     ,@(if (and restp (= max-n-regular rest-clause-n-regular))
                         `((,rest-var ,input)) nil))
                ,@(case-lambda--body rest-clause)))
           (error-form
             (if restp rest-clause-form '(error "case-lambda matching failure")))
           (resform error-form))
      ;; main loop
      (do ((cs clauses (cdr cs)))
          ((null (cdr cs)) (setq clauses cs))
        (let ((c (car cs))
              (nextc (cadr cs)))
          (case-lambda--build-bind-if-tree)))
      ;; handle the begining
      (if (= 0 (case-lambda--n-regular (car clauses)))
        (setq resform
          `(if (null ,input)
             ,@(case-lambda--body (car clauses))
             ,resform))
        (let ((c (car clauses))
              (nextc nil))
          (case-lambda--build-bind-if-tree)
          (setq resform
            `(if (null ,input)
               ,(if (and restp (= 0 rest-clause-n-regular))
                  rest-clause-form
                  error-form)
               ,resform))))
      (and restp (= 0 rest-clause-n-regular)
        (setq resform
          `(let ((,rest-var ,input))
             ,resform)))
      `(lambda (&rest ,input)
         ,resform)))

  (defmacro case-lambda (&rest clauses)
    "return a anoymous function that dispatch on arguments number.
  (case-lambda (formals body ...) ...)
  where formals = (id ... [&rest id])"
    (let ((clauses (case-lambda--remove-unreachable
                     (case-lambda--analyze clauses))))
      (cond ((null clauses) '(lambda () nil))
            ((null (cdr clauses))
             (cons 'lambda (case-lambda--arglist-body (car clauses))))
            (t (case-lambda--main-pattern clauses)))))

  ; (macroexpand '(case-lambda ((x y) (+ x y)) ((x y z) (- x y z))))
  ; (macroexpand '(case-lambda ((x y) (+ x y)) ((w x y z) (- w x y z))))
  ; (macroexpand '(case-lambda ((x y z) (- x y z)) ((&rest xs) (cons 1 xs))))
  ; (macroexpand '(case-lambda ((x y z) (- x y z)) ((x &rest xs) (list 1 x xs))))
  ; (macroexpand '(case-lambda
  ;                 ((x y z) (- x y z))
  ;                 ((a b c d e &rest xs) (list a b c d e xs))))

  (defmacro case-defun (name &rest xs)
    "define a function named NAME that dispatch on arguments number.
  (case-defun name (formals body ...) ...)
  where formals = (id ... [&rest id])"
    `(setf (symbol-function ',name)
       (case-lambda ,@xs)))

  (defmacro case-defmacro (name &rest xs)
    "define a macro named NAME that dispatch on arguments number.
  (case-defmacro name (formals body ...) ...)
  where formals = (id ... [&rest id])"
    (let ((x (gensym)))
      `(defmacro ,name (&rest ,x)
         (apply (case-lambda ,@xs) ,x))))

  ; (case-defun range
  ;   ((x) (range 0 x 1))
  ;   ((x y) (range x y 1))
  ;   ((x y z)
  ;    (loop for i from x below y by z collect i)))
#+end_src
:end:

** å¦ä¸€ç§æ€è·¯ -- é€ä¸ªç»‘å®šå‚æ•°å¹¶æ£€æŸ¥

SRFI-16 çš„å‚è€ƒå®žçŽ°å…è®¸å­å¥ä¸­çš„å‚æ•°æ•°é‡å¹¶ä¸æŒ‰ç…§é€’å¢žçš„é¡ºåºå‡ºçŽ°ï¼Œä½†æ˜¯å¦‚æžœæˆ‘ä»¬â€‹*è¦æ±‚*â€‹å®ƒä»¬æŒ‰å‡åºå‡ºçŽ°çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆåˆ›å»ºä¸€ä¸ªå˜é‡åˆ—è¡¨ï¼Œç„¶åŽé€æ¬¡è¿›è¡Œå‚æ•°ç»‘å®šç›´åˆ°ç©·å°½å‚æ•°ï¼Œå¹¶åˆ¤æ–­æ­¤æ—¶çš„å‚æ•°æ•°é‡èƒ½å¦ä¸ŽæŸä¸€å­å¥åŒ¹é…ï¼Œä»Žè€Œè°ƒç”¨å¯¹åº”çš„è¡¨è¾¾å¼ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªè¯´æ˜Žæ€§çš„ä¾‹å­ï¼š

#+begin_src elisp
  (case-lambda ((x y) (+ x y)) ((a b c d) (+ a b c d)))

  (lambda (&rest g0)
    (if (null g0)
        (error "case-lambda match failure") ; <-- no argument
      (let ((g1 (car g0)))
        (setq g0 (cdr g0))
        (if (null g0)
            (error "case-lambda match failure") ; <-- only one argument
          (let ((g2 (car g0)))
            (setq g0 (cdr g0))
            (if (null g0)
                (let ((x g1) (y g2)) ; <-- first case, two arguments
                  (+ x y))
              (let ((g3 (car g0)))
                (setq g0 (cdr g0))
                (if (null g0)
                    (error "case-lambda match failure") ; <-- three arguments
                  (let ((g4 (car g0)))
                    (setq g0 (cdr g0))
                    (if (null g0)
                        (let ((a g1) (b g2) (c g3) (d g4)) ; <-- second case,
                          (+ a b c d))                     ; four arguments
                      (error "case-lambda match failure")))))))))))
#+end_src

åœ¨ä»–çš„ä»£ç ä¸­ï¼Œç¬¬ä¸€ä¸ªå‡½æ•°ç”¨äºŽæ£€æŸ¥å‚æ•°åˆ—è¡¨æ˜¯å¦ä¸ºå¸¸è§„åˆ—è¡¨ï¼Œä¸è¿‡åœ¨ Elisp ä¸­æˆ‘ä»¬æœ‰ =proper-list-p= å¯ç”¨ã€‚ç´§æŽ¥ç€æ˜¯ä¸€äº› getter å‡½æ•°ï¼Œç”¨äºŽä»Žè¢«ã€Œåˆ†æžã€åŽçš„å­å¥ä¸­æå–ç»„æˆï¼Œæ„Ÿè§‰è¿™é‡Œæœ€å¥½åŠ ä¸Šæ³¨é‡Šè¯´æ˜Žç”¨é€”ï¼š

#+begin_src elisp
  ;; èŽ·å–å­å¥çš„å›ºå®šå‚æ•°ä¸ªæ•°
  (defmacro case-lambda--n-regular (x)
    `(caar ,x))
  ;; åˆ¤æ–­å­å¥æ˜¯å¦å…·æœ‰å‰©ä½™å‚æ•°
  (defmacro case-lambda--restp (x)
    `(cdar ,x))
  ;; èŽ·å–å­å¥çš„å‰©ä½™å‚æ•°å
  (defmacro case-lambda--restvar (x)
    `(cdar ,x))
  ;; èŽ·å–å­å¥çš„å‚æ•°åˆ—è¡¨å’Œå‡½æ•°ä½“ç»„æˆçš„åˆ—è¡¨
  (defmacro case-lambda--arglist-body (x)
    `(cdr ,x))
  ;; èŽ·å–å­å¥çš„å‚æ•°åˆ—è¡¨
  (defmacro case-lambda--arglist (x)
    `(car (case-lambda--arglist-body ,x)))
  ;; èŽ·å–å­å¥çš„å‡½æ•°ä½“
  (defmacro case-lambda--body (x)
    `(cdr (case-lambda--arglist-body ,x)))
  ;; æž„é€ ã€Œåˆ†æžã€åŽçš„å­å¥ç»“æž„
  (defun case-lambda--make-clause (n-regular restvar arglist body)
    (cons (cons n-regular restvar) (cons arglist body)))
#+end_src

=case-lambda--analyze= è´Ÿè´£å°† =case-lambda= ä¸­çš„æ‰€æœ‰å­å¥é€šè¿‡ =case-lambda--make-clause= è½¬æ¢æˆä¸€ç§æ›´å®¹æ˜“åˆ†æžçš„æž„é€ ï¼š

#+begin_src elisp
  (defun case-lambda--analyze (clauses)
    "convert clauses litteral to internal structure"
    (let ((res nil))
      (dolist (c clauses (nreverse res))
        (or (consp c)
            (case-lambda--pure-list-p c)
            (case-lambda--pure-list-p (car c))
          (error "Bad case-lambda clauses"))
        (let* ((arglist (car c))
               (restp (member '&rest arglist))
               (len-after-rest (and restp (length restp)))
               (n-regular (if (not restp)
                            (length arglist)
                            (- (length arglist) len-after-rest))))
          (and restp (/= 2 len-after-rest)
            (error "Bad case-lambda clauses"))
          (push (case-lambda--make-clause
                  n-regular (cadr restp) (cl-subseq arglist 0 n-regular) (cdr c))
                res)))))
#+end_src

ä½ å¯ä»¥æ³¨æ„åˆ°å®ƒæ£€æŸ¥äº†æ‰€æœ‰çš„å­å¥çš„å‚æ•°åˆ—è¡¨å¹¶ç¡®ä¿å®ƒä»¬éƒ½æ˜¯å¸¸è§„åˆ—è¡¨ï¼Œè¿™ä¸Ž Scheme ä¸å¤ªä¸€æ ·ï¼Œå› ä¸ºåœ¨ CL/Elisp ä¸­å‰©ä½™å‚æ•°ä½¿ç”¨ =(&rest args)= æ¥è¡¨ç¤ºã€‚é™¤æ­¤ä¹‹å¤– CL/EL è¿˜å…è®¸ä½¿ç”¨ =&optional= æŒ‡å®šä¸€ä¸ªå¯é€‰å‚æ•°ï¼Œå¦‚æžœä½œè€…çš„ç›®æ ‡æ˜¯å¤åˆ» =case-lambda=â€‹ï¼Œä¸æ”¯æŒ =&optional= æ˜¯å¯ä»¥ç†è§£çš„ã€‚åœ¨è°ƒç”¨ =case-lambda--make-clause= çš„è¡¨è¾¾å¼ä¸­ä½ å¯ä»¥å‘çŽ°ä½œè€…ä½¿ç”¨äº† =cl-subseq= æ¥ä»…å–å‚æ•°åˆ—è¡¨çš„å›ºå®šå‚æ•°ä½œä¸ºæž„é€ ä¸­çš„å‚æ•°åˆ—è¡¨ã€‚

åœ¨ =case-lambda= çš„å®šä¹‰ä¸­ï¼Œâ€‹=case-lambda--analyze= çš„è¿”å›žå€¼ç›´æŽ¥ä½œä¸ºäº† =case-lambda--remove-unreachable= çš„å‚æ•°æ¥èŽ·å–ç»è¿‡æ¸…ç†ä¸”åè½¬çš„å­å¥æž„é€ åˆ—è¡¨ï¼š

#+begin_src elisp
  (defmacro case-lambda (&rest clauses)
    "return a anoymous function that dispatch on arguments number.
  (case-lambda (formals body ...) ...)
  where formals = (id ... [&rest id])"
    (let ((clauses (case-lambda--remove-unreachable
                    (case-lambda--analyze clauses))))
      (cond ((null clauses) '(lambda () nil))
            ((null (cdr clauses))
             (cons 'lambda (case-lambda--arglist-body (car clauses))))
            (t (case-lambda--main-pattern clauses)))))

  (defun case-lambda--remove-unreachable (clauses)
    "remove unreachable clauses and return reversed result"
    (let ((res nil)
          (max-n-regular -1)
          (restp nil))
      (do ((cs clauses (cdr cs)))
          ((null cs) res)
          (let ((c (car cs)))
            (or restp
                (cond ((case-lambda--restp c)
                       (setq restp t)
                       (push c res))
                      ((> (case-lambda--n-regular c) max-n-regular)
                       (setq max-n-regular (case-lambda--n-regular c))
                       (push c res))))))))
#+end_src

ä½ å¯ä»¥æ³¨æ„åˆ°åœ¨ =case-lambda--remove-unreachable= ä¸­ï¼Œå¦‚æžœæŸä¸ªå­å¥å«æœ‰å‰©ä½™å‚æ•°å®ƒå°†ä¼šæˆä¸ºæœ€åŽä¸€ä¸ªå­å¥ï¼Œå¦‚æžœå®ƒä¸å«å‰©ä½™å‚æ•°ä¸”å›ºå®šå‚æ•°æ•°é‡å°äºŽå…ˆå‰å­å¥çš„æœ€å¤§å›ºå®šå‚æ•°æ•°é‡å®ƒä¼šè¢«ç›´æŽ¥å¿½ç•¥ã€‚è¿™å¯¹äºŽä½œè€…ã€ŒæŒ‰ç…§å‚æ•°æ•°é‡æŽ’åˆ—å­å¥ã€çš„è®¾æƒ³æ¥è¯´æ²¡ä»€ä¹ˆé—®é¢˜ï¼ˆå¤§æ¦‚ï¼Ÿï¼‰ã€‚

** éš¾æ‡‚çš„éžå«ç”Ÿå®

å½“ =case-lambda= ä»…æœ‰ä¸€æ¡å­å¥æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå½“ä½œæ™®é€šçš„å‡½æ•°å¤„ç†å³å¯ï¼Œæ•´ä¸ªå®žçŽ°çœŸæ­£éº»çƒ¦çš„éƒ¨åˆ†åœ¨ =case-lambda--main-pattern= ä¸Šã€‚æˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ä»…å˜é‡ç»‘å®šéƒ¨åˆ†å°±æœ‰ 12 ä¸ªå˜é‡ï¼Œæ›´ä¸ç”¨è¯´ã€Œèº«é¦–å¼‚å¤„ã€çš„ =case-lambda--build-bind-if-tree= äº†ï¼š

#+begin_src elisp
  (let* ((restp (case-lambda--restp (car clauses)))
         (rest-clause (car clauses))
         (rest-clause-n-regular
          (and restp (case-lambda--n-regular rest-clause)))
         (first-clause-with-only-regulars-n-regular
          (if restp (case-lambda--n-regular (cadr clauses))
            (case-lambda--n-regular (car clauses))))
         (max-n-regular
          (if restp
              (max rest-clause-n-regular
                   first-clause-with-only-regulars-n-regular)
            first-clause-with-only-regulars-n-regular))
         (regular-tmps
          (let ((res nil))
            (dotimes (i max-n-regular res)
              (push (gensym) res))))
         (rest-var (and restp (case-lambda--restvar rest-clause)))
         (input (gensym))
         (rest-at (and restp (- rest-clause-n-regular 1)))
         (rest-clause-form 
          `(let (,@(cl-mapcar #'list (case-lambda--arglist rest-clause)
                              regular-tmps)
                 ,@(if (and restp (= max-n-regular rest-clause-n-regular))
                       `((,rest-var ,input)) nil))
             ,@(case-lambda--body rest-clause)))
         (error-form
          (if restp rest-clause-form '(error "case-lambda matching failure")))
         (resform error-form))
    ...)
#+end_src

ä»Žå®žçŽ°ä¸Šæ¥è¯´ï¼ŒçœŸæ­£çš„ä¸»å¾ªçŽ¯åªæœ‰ä¸€å°æ®µï¼Œä½†å°±æ˜¯è¿™ä¸€å°æ®µçœ‹çš„æˆ‘æœ‰ç‚¹å¤§è„‘èŽç¼©ã€‚æˆ‘ä»¬é˜…è¯»ä»£ç çš„æ—¶å€™æœ€å¥½æŠŠ =case-lambda--build-if-tree= ç›´æŽ¥å¤åˆ¶è¿‡æ¥ï¼Œå°±åƒè¿™æ ·ï¼š

#+begin_src elisp
  ;; main loop
  (do ((cs clauses (cdr cs)))
      ((null (cdr cs)) (setq clauses cs))
      (let ((c (car cs))
            (nextc (cadr cs)))
        (case-lambda--build-bind-if-tree)))
  ;;=>

  (do ((cs clauses (cdr cs)))
      ((null (cdr cs)) (setq clauses cs))
      (let ((c (car cs))
            (nextc (cadr cs)))
        (let ((n-regular (case-lambda--n-regular c))
              (nc-n-regular (if nextc (case-lambda--n-regular nextc) 0)))
          (do ((i (- n-regular 1) (- i 1)))
              ((< i nc-n-regular))
              (setq resform
                    `(if (null ,input)
                         ,(if (= i (- n-regular 1))
                              `(let (,@(cl-mapcar #'list (case-lambda--arglist c)
                                                  regular-tmps))
                                 ,@(case-lambda--body c))
                            error-form)
                       ,resform))
              (when (and restp (= i rest-at))
                (setq resform
                      `(let ((,rest-var ,input))
                         ,resform)))
              (setq resform
                    `(let ((,(nth i regular-tmps) (car ,input)))
                       (setq ,input (cdr ,input))
                       ,resform))
              (when (and restp (<= i rest-at))
                (setq error-form '(error "case-lambda matching failure")))))))
#+end_src

è€ƒè™‘åˆ°æ‹¥æœ‰æœ€å¤šå‚æ•°çš„å­å¥è¦ç•™åˆ°æœ€åŽå¤„ç†ï¼ˆä½äºŽåµŒå¥—çš„æœ€æ·±å¤„ï¼‰ï¼Œè€Œä»£ç ç”Ÿæˆæ˜¯ä¸€å±‚å¥—ä¸€å±‚çš„ï¼Œâ€‹=case-lambda--main-pattern= æŽ¥å—åè½¬çš„å­å¥æ˜¯éžå¸¸åˆç†çš„åšæ³•ã€‚åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå¤–å±‚å¾ªçŽ¯ =(do ((cs clauses ...)))= çš„ä½œç”¨æ˜¯æŒ‰é¡ºåºã€Œå‰¥ç¦»ã€å­å¥æž„é€ ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå®ƒèŽ·å–å½“å‰å­å¥ =c= å’Œä¸‹ä¸€å­å¥ =nextc=â€‹â€‹ï¼Œç„¶åŽè°ƒç”¨ =case-lambda--build-bind-if-tree= æ¥ç”Ÿæˆå¤„ç†å„å­å¥çš„æ‰€æœ‰ä»£ç å±‚ã€‚

å†…å­˜å¾ªçŽ¯ (=case-lambda--build-bind-if-tree)= çš„ä½œç”¨æ˜¯å¤„ç†ç›¸é‚»å­å¥ä¹‹é—´çš„ã€Œç©ºç¼ºã€ï¼ˆæ¯”å¦‚ä¸¤ä¸ªå­å¥åˆ†åˆ«æœ‰ 4 ä¸ªå’Œ 2 ä¸ªå‚æ•°ï¼Œä¸­é—´çš„ 3 ä¸ªå‚æ•°ä¸å­˜åœ¨å¯¹åº”å­å¥éœ€è¦æŠ¥é”™ï¼‰ã€‚å®ƒé€šè¿‡ =i= ä»Žå­å¥ =c= çš„å›ºå®šå‚æ•°æ•°é‡å‡ä¸€è¿­ä»£åˆ° =nextc= å­å¥ä¸­çš„å›ºå®šå‚æ•°æ•°ã€‚è¿™é€šè¿‡ =setq resform= åå¤å°† =resform= åŒ…è£¹åœ¨æ–°çš„ä»£ç å±‚ä¸­ï¼š

- åœ¨é¦–æ¬¡è¿­ä»£æ—¶ï¼Œ ~(= i (- n-regular 1))~ æˆç«‹ï¼Œæ­¤æ—¶ä¼šåˆ›å»º =let= ç»‘å®šå°†å­å¥çš„å‚æ•°ä¸Žå®žå‚å¯¹åº”çš„ä¸´æ—¶åå­—ç»‘å®šå¹¶è°ƒç”¨è¡¨è¾¾å¼ï¼›åŽç»­çš„æž„é€ è¿‡ç¨‹åªä¼šç”Ÿæˆå¼•å‘é”™è¯¯çš„è¡¨è¾¾å¼ï¼Œå³å¯¹åº”äºŽå­å¥ç©ºç¼ºçš„æƒ…å†µ
  #+begin_src elisp
    (setq resform
          `(if (null ,input)
               ,(if (= i (- n-regular 1))
                    `(let (,@(cl-mapcar #'list (case-lambda--arglist c)
                                        regular-tmps))
                       ,@(case-lambda--body c))
                  error-form)
             ,resform))
  #+end_src

- è¿­ä»£è¿‡ç¨‹ä¸­ä¼šä¸æ–­å°†è¾“å…¥å‚æ•°ç»‘å®šåˆ°å„ä¸´æ—¶åå­—ä¸Šï¼Œä»¥æ­¤ã€Œæ¶ˆè€—ã€è¾“å…¥ï¼š
  #+begin_src elisp
    (setq resform
          `(let ((,(nth i regular-tmps) (car ,input)))
             (setq ,input (cdr ,input))
             ,resform))
  #+end_src

ç†è§£äº† =case-lambda--build-if-tree= åŸºæœ¬ä¸Šå°±ç†è§£äº†æ•´ä½“æ€è·¯ï¼Œä¸‹é¢æ˜¯ =case-lambda--main-pattern= çš„å‰©ä½™éƒ¨åˆ†ï¼š

#+begin_src elisp
  ;; handle the begining
  (if (= 0 (case-lambda--n-regular (car clauses)))
      (setq resform
            `(if (null ,input)
                 ,@(case-lambda--body (car clauses))
               ,resform))
    (let ((c (car clauses))
          (nextc nil))
      (case-lambda--build-bind-if-tree)
      (setq resform
            `(if (null ,input)
                 ,(if (and restp (= 0 rest-clause-n-regular))
                      rest-clause-form
                    error-form)
               ,resform))))
  (and restp (= 0 rest-clause-n-regular)
       (setq resform
             `(let ((,rest-var ,input))
                ,resform)))
  `(lambda (&rest ,input)
     ,resform))
#+end_src

å¦‚æžœä½ å¼„æ˜Žç™½äº† =case-lambda--build-bind-if-tree= çš„å·¥ä½œåŽŸç†ï¼Œè¿™é‡Œåº”è¯¥æ¯”è¾ƒå®¹æ˜“æ‡‚äº†ã€‚æ³¨æ„ï¼Œæ­¤æ—¶ =clauses= å¯¹åº”çš„æ˜¯ =case-lambda= ä¸­çš„ç¬¬ä¸€ä¸ªå­å¥ï¼Œå¦‚æžœå®ƒçš„å›ºå®šå‚æ•°æ•°é‡ä¸º 0 éœ€è¦ä¸€äº›ç‰¹æ®Šå¤„ç†ã€‚

å¦‚æžœä½ çœ‹åˆ°è¿™é‡Œèƒ½çœ‹æ‡‚ï¼Œé‚£ä½ æ˜¯è¿™ä¸ªðŸ‘ã€‚ç”·äººï¼ä»€ä¹ˆç½å¤´æˆ‘è¯´ï¼Œé»‘çœ¼é•œè›‡å‡ºåŽ»ã€‚

* æ”¹è¿›çš„å®žçŽ°

è¿™ä¸ªä»£ç çœ‹ç€å¯å°±èˆ’æœå¤šäº†~å®ƒæœ€å¤§çš„æ”¹è¿›å°±æ˜¯å°†é‚£æ®µå®åˆå¹¶åˆ°äº†å‡½æ•°ä¸­ä¸”é‡æŽ’äº†å…¶ä¸­ä¸€äº›è¡¨è¾¾å¼çš„é¡ºåºã€‚

#+begin_src lisp
  ;;; case-lambda  -*- lexical-binding: t; -*-

  ;;; consider (case-lambda ((x y) (+ x y)) ((a b c d) (+ a b c d)))
  ;;; it would be nice that expand to

  ;;; (lambda (&rest g0)
  ;;;   (if (null g0)
  ;;;     (error "case-lambda match failure") ; <-- no argument
  ;;;     (let ((g1 (car g0)))
  ;;;       (setq g0 (cdr g0))
  ;;;       (if (null g0)
  ;;;         (error "case-lambda match failure") ; <-- only one argument
  ;;;         (let ((g2 (car g0)))
  ;;;           (setq g0 (cdr g0))
  ;;;           (if (null g0)
  ;;;             (let ((x g1) (y g2)) ; <-- first case, two arguments
  ;;;               (+ x y))
  ;;;             (let ((g3 (car g0)))
  ;;;               (setq g0 (cdr g0))
  ;;;               (if (null g0)
  ;;;                 (error "case-lambda match failure") ; <-- three arguments
  ;;;                 (let ((g4 (car g0)))
  ;;;                   (setq g0 (cdr g0))
  ;;;                   (if (null g0)
  ;;;                     (let ((a g1) (b g2) (c g3) (d g4)) ; <-- second case,
  ;;;                       (+ a b c d))                     ; four arguments
  ;;;                     (error "case-lambda match failure")))))))))))

  ;;; By inspecting the expression above, we can see that it is essentially a
  ;;; nested form of the following pattern.

  ;;; (if (null g0)
  ;;;   match-success-or-failure
  ;;;   bind-rest-or-failure)

  ;;; where match-success-or-failure is either (error ...) or (let ...)
  ;;; bind-rest-or-failure is either (let ((gN (car g0))) (setq g0 (cdr g0)) ...)
  ;;;   or (error ...)
  ;;; which may build through a recursive routine easily, but could also build
  ;;; reversed, from the deepest (error ...) form to the top (if ...) form

  ;;; then, let's involve &rest, consider
  ;;; (case-lambda ((x) x) ((i j k) (list i j k)) ((a &rest b) (list a b)))
  ;;; the failure form would be the rest clause if possible, like

  ;;; (lambda (&rest g0)
  ;;;   (if (null g0)
  ;;;     (error "case-lambda match failure") ; <-- failure form that raise an
  ;;;                                         ;     error
  ;;;     (let ((g1 (car g0)))
  ;;;       (setq g0 (cdr g0))
  ;;;       (let ((rest0 g0)) ; <-- preserve for the rest variable b
  ;;;         (if (null g0)
  ;;;           (let ((x g1)) x) ; <-- case 1
  ;;;           (let ((g2 (car g0)))
  ;;;             (setq g0 (cdr g0))
  ;;;             (if (null g0)
  ;;;               (let ((a g1) (b rest0)) ; <-- note that this is actually a
  ;;;                 (list a b))           ;     failure form, with rest clause
  ;;;                                       ;     involved and applied
  ;;;               (let ((g3 (car g0)))
  ;;;                 (setq g0 (cdr g0))
  ;;;                 (if (null g0)
  ;;;                   (let ((i g1) (j g2) (k g3)) ; <-- the last case
  ;;;                     (list i j k))
  ;;;                   (let ((a g1) (b rest0)) ; <-- still the rest clause
  ;;;                     (list a b)))))))))))

  ;;; finally, consider this (case-lambda ((x) 1) ((&rest xs) xs)), this should
  ;;; construct (let ((rest0 g0)) ...) before any expression

  (defun case-lambda--pure-list-p (x)
    (cl-do ((x x (cdr x)))
        ((not (consp x)) (null x))))

  (defun case-lambda--check-syntax (clauses)
    ;; assume clauses is generate by reader so that it couldn't be non-pure list
    (cl-assert (case-lambda--pure-list-p clauses))
    (dolist (c clauses)
      (unless (consp c)
        (error "bad case-lambda syntax"))
      (let ((arglist (car c))
            (body (cdr c)))
        (when (or (not (case-lambda--pure-list-p arglist))
                  (not (case-lambda--pure-list-p body)))
          (error "bad case-lambda syntax"))
        (when (let* ((rest-form (member '&rest arglist))
                     (len (length rest-form)))
                (and (/= 0 len) (/= 2 len)))
          (error "bad case-lambda syntax")))))

  ;; case-lambda clause descriptor
  (defun case-lambda--make-clamcd (restp n-regular regular-arglist body)
    "make a case-lambda clause descriptor
  RESTP should be either rest argument name or nil
  N-REGULAR is how many regular arguments
  REGUAR-ARGLIST is regular arguments form"
    (cons (cons restp n-regular) (cons regular-arglist body)))
  (defmacro clamcd--restp (x)
    `(caar ,x))
  (defmacro clamcd--restvar (x)
    `(caar ,x))
  (defmacro clamcd--n-regular (x)
    `(cdar ,x))
  (defmacro clamcd--regular-arglist (x)
    `(cadr ,x))
  (defmacro clamcd--body (x)
    `(cddr ,x))

  (defun case-lambda--analyze-clauses (clauses)
    "return reversed clause descriptors that unreachable clauses are removed"
    (let ((result nil) (max-n-regular -1) (already-restp nil))
      (dolist (c clauses result) ; note function result is declared here
        (let* ((arglist (car c))
               (restp (member '&rest arglist))
               (restvar (and restp (cadr restp)))
               (n-regular (if restp (- (length arglist) 2) (length arglist)))
               (regulars (cl-subseq arglist 0 n-regular))
               (body (cdr c)))
          (when (and (not already-restp)
                     (or restp (> n-regular max-n-regular)))
            (when restp (setq already-restp restp))
            (setq max-n-regular (max n-regular max-n-regular))
            (push (case-lambda--make-clamcd restvar n-regular regulars body)
                  result))))))

  ;; you should read the section comments above before read this function
  (defun case-lambda--build-main-form (clamcds)
    ;; note that clamcds is now reversed, so the max-n-regular clause or
    ;; the rest clause is sit on the top
    (let* ((first-clamcd (car clamcds))
           (second-clamcd (cadr clamcds))
           (restp (clamcd--restp first-clamcd))
           (rest-clamcd (and restp first-clamcd))
           (restvar (and restp (clamcd--restvar rest-clamcd)))
           (rest-n-regular (and restp (clamcd--n-regular rest-clamcd)))
           ;; n-regular of rest clause could smaller than max-n-regular
           (max-n-regular (max (clamcd--n-regular first-clamcd)
                               (clamcd--n-regular second-clamcd)))
           ;; gensyms
           (input-tmp (gensym "INPUT"))
           (regular-tmps
            (let ((res nil))
              (dotimes (_ max-n-regular res)
                (push (gensym "G") res))))
           (rest-tmp (gensym "REST"))
           ;; the failure-form
           (failure-form
            (if (not restp)
              '(error "case-lambda match failure")
              (let ((rest-clause-regular-arglist (clamcd--regular-arglist rest-clamcd)))
                `(let (,@(mapcar 'list rest-clause-regular-arglist regular-tmps)
                       (,restvar ,rest-tmp))
                   ,@(clamcd--body first-clamcd)))))
           (resform failure-form))
      (cl-do ((clamcds clamcds (cdr clamcds)))
          ((null clamcds)
           `(lambda (&rest ,input-tmp) ; <-- see, the result
              ,(if (and restp (= 0 (clamcd--n-regular first-clamcd)))
                `(let ((,rest-tmp ,input-tmp))
                   ,resform)
                resform)))
        (let* ((clamcd (car clamcds))
               (next-clamcd (cadr clamcds))
               (n-regular (if (and restp (eq clamcd rest-clamcd))
                            max-n-regular
                            (clamcd--n-regular clamcd)))
               (next-n-regular
                 (if (null next-clamcd) -1 (clamcd--n-regular next-clamcd))))
          ;; note that if the rest clause and the previous clause has same number
          ;; of regular arguments, this do loop will simply skip the rest clause
          (cl-do ((i n-regular (- i 1)))
              ((= i next-n-regular))
            (when (and restp (= i (- rest-n-regular 1)))
              (setq failure-form '(error "case-lambda match failure"))
              (setq resform
                `(let ((,rest-tmp ,input-tmp))
                   ,resform)))
            (setq resform
              `(if (null ,input-tmp)
                 ,(if (= i n-regular)
                    `(let (,@(cl-mapcar 'list (clamcd--regular-arglist clamcd) regular-tmps)
                           ,@(if (and restp (= i max-n-regular)
                                      (= rest-n-regular max-n-regular)
                                      (/= rest-n-regular (clamcd--n-regular second-clamcd)))
                               ;; if it is the deepest form, and it has the most
                               ;; of regular arguments, and previous clause
                               ;; doesn't has the same number of arguments with
                               ;; this clause (which is rest clause),
                               ;; which is, if the rest clause has the most of
                               ;; regular arguments, and no other clauses have
                               ;; the most of regular arguments
                               `((,restvar ,rest-tmp))
                               nil))
                       ,@(clamcd--body clamcd))
                    failure-form)
                 ,(if (= i max-n-regular)
                    failure-form
                    `(let ((,(nth i regular-tmps) (car ,input-tmp)))
                       (setq ,input-tmp (cdr ,input-tmp))
                       ,resform)))))))))


  (defmacro case-lambda (&rest clauses)
    (case-lambda--check-syntax clauses)
    (let ((clamcds (case-lambda--analyze-clauses clauses)))
      (cl-case (length clamcds)
        (0 '(lambda () nil))
        (1 (let ((d (car clamcds)))
             (if (clamcd--restp d)
               `(lambda (,@(clamcd--regular-arglist d) &rest ,(clamcd--restvar d))
                  ,@(clamcd--body d))
               (cons 'lambda (cons (clamcd--regular-arglist d) (clamcd--body d))))))
        (otherwise
         (case-lambda--build-main-form clamcds)))))

  (defmacro case-defun (name &rest clauses)
    `(progn
       (declaim (ftype (function (&rest t) (values &rest t)) ,name))
       (setf (symbol-function ',name) (case-lambda ,@clauses))))

  (defmacro case-defmacro (name &rest clauses)
    (let ((xs (gensym)))
      `(defmacro ,name (&rest ,xs)
         (apply (case-lambda ,@clauses) ,xs))))

  ; (case-defun range
  ;   ((m) (range 0 m 1))
  ;   ((m n) (range m n 1))
  ;   ((m n k)
  ;    (loop for i from m below n by k collect i)))

  ; (macroexpand '(case-lambda))
  ; (macroexpand '(case-lambda ((x y) (+ x y))))
  ; (macroexpand '(case-lambda (() 1) ((x y) (+ x y))))
  ; (macroexpand '(case-lambda ((x y) (+ x y)) ((x y z) (- x y z))))
  ; (macroexpand '(case-lambda ((x y z) (+ x y z)) ((w x y z) (- w x y z))))
  ; (macroexpand '(case-lambda ((x y) (+ x y)) ((w x y z) (- w x y z))))
  ; (macroexpand '(case-lambda ((x y z) (- x y z)) ((&rest xs) (cons 1 xs))))
  ; (macroexpand '(case-lambda ((x y z) (- x y z)) ((x &rest xs) (list 1 x xs))))
  ; (macroexpand '(case-lambda ((x y z) (- x y z)) ((x y z &rest xs) (list 1 x xs))))
  ; (macroexpand '(case-lambda
  ;                 ((x y z) (- x y z))
  ;                 ((a b c d e &rest xs) (list a b c d e xs))))

  ;  (case-defun map*
  ;    ((f xs)
  ;     (if (null xs)
  ;       nil
  ;       (let* ((res (cons (funcall f (car xs)) nil))
  ;              (cur res))
  ;         (dolist (x (cdr xs) res)
  ;           (rplacd cur (cons (funcall f x) nil))
  ;           (setq cur (cdr cur))))))
  ;    ((f xs ys)
  ;     (if (or (null xs) (null ys))
  ;       nil
  ;       (let* ((res (cons (funcall f (car xs) (car ys)) nil))
  ;              (cur res))
  ;         (do ((xs (cdr xs) (cdr xs))
  ;              (ys (cdr ys) (cdr ys)))
  ;             ((or (null xs) (null ys))
  ;              res)
  ;           (rplacd cur (cons (funcall f (car xs) (car ys)) nil))
  ;           (setq cur (cdr cur))))))
  ;    ((f xs ys zs)
  ;     (if (or (null xs) (null ys) (null zs))
  ;       nil
  ;       (let* ((res (cons (funcall f (car xs) (car ys) (car zs)) nil))
  ;              (cur res))
  ;         (do ((xs (cdr xs) (cdr xs))
  ;              (ys (cdr ys) (cdr ys))
  ;              (zs (cdr zs) (cdr zs)))
  ;             ((or (null xs) (null ys) (null zs))
  ;              res)
  ;           (rplacd cur (cons (funcall f (car xs) (car ys) (car zs)) nil))
  ;           (setq cur (cdr cur))))))
  ;    ((f ws xs ys &rest zs)
  ;     (declare (inline map* some))
  ;     (if (or (null ws) (null xs) (null ys)
  ;             (some #'null zs))
  ;       nil
  ;       (let* ((res (cons (apply f (car ws) (car xs) (car ys) (map* #'car zs)) nil))
  ;              (cur res))
  ;         (do ((ws (cdr ws) (cdr ws))
  ;              (xs (cdr xs) (cdr xs))
  ;              (ys (cdr ys) (cdr ys))
  ;              (zs (map* #'cdr zs) (map* #'cdr zs)))
  ;             ((or (null ws) (null xs) (null ys) (some #'null zs))
  ;              res)
  ;           (rplacd cur (cons (apply f (car ws) (car xs) (car ys)
  ;                                    (map* #'car zs))
  ;                             nil))
  ;           (setq cur (cdr cur)))))))
#+end_src

å¦‚æžœæ˜¯æˆ‘çš„è¯ï¼Œå¯èƒ½è¿˜ä¼šæŠŠå­å¥æž„é€ æ”¹æˆ =cl-defstruct= çš„å½¢å¼ç„¶åŽæ·»åŠ ç‚¹æ³¨é‡Šã€‚ä¸è¿‡åœ¨ä¸Šé¢çš„å®žçŽ°ä¸­æ›´å€¼å¾—å…³æ³¨çš„æ˜¯ =case-lambda--build-main-form= è¿™ä¸ªå·¨é•¿æ— æ¯”çš„å‡½æ•°ï¼Œåº”è¯¥è€ƒè™‘å°†å®ƒæ‹†åˆ†æˆæ›´å·²è¯»çš„å°å‡½æ•°ã€‚

** ä»Žé€’å½’çš„æ€è·¯å‡ºå‘

è€å®žè¯´ï¼Œåœ¨çœ‹åˆ°ä¸Šé¢è¿™æ®µä»£ç æ—¶ï¼Œæˆ‘æ›´å€¾å‘äºŽä»Žé€’å½’è€Œä¸æ˜¯è¿­ä»£çš„æ€è·¯æ¥å†™ã€‚æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°çœ‹å‡ºè¿™æ˜¯ä¸ªå°†å­å¥å±•å¼€ä¸ºåµŒå¥— =if= çš„è¿‡ç¨‹ï¼Œæˆ–è€…è¯´å‰ä¸€å­å¥å°±æ˜¯å¯¹åŽé¢æ‰€æœ‰å­å¥åŠ ä¸Šæ–°çš„å†…å®¹è€Œå·²ï¼Œå°±åƒæ˜¯ =(if cond dosomething rest)= çš„æ„Ÿè§‰ï¼Œè€Œ =rest= å†…å®¹å¯ä»¥ç”±é€’å½’è°ƒç”¨æ¥ç”Ÿæˆã€‚

#+begin_src elisp
  ;; -*- lexical-binding: t; -*-

  (defun c--ensure-proper-arglists (clauses)
    "Ensure clauses' arglist are all proper lists."
    (thread-first 
      (lambda (ls)
        (and (proper-list-p ls)
             (cl-every (lambda (s)
                         (and (symbolp s)
                              (not (keywordp s))))
                       ls)))
      (cl-every (mapcar #'car clauses))
      (unless (error "Invalid arglist exist in %s" clauses))))

  (defmacro case-lambda (&rest clauses)
    "The case-lambda macro"
    (c--ensure-proper-arglists clauses)
    (pcase (length clauses)
      (0 '(lambda () nil))
      (1 `(lambda ,@(car clauses)))
      (_ (let ((input (gensym "ARGS")))
           `(lambda (&rest ,input)
              ,(case-lambda-1 clauses 0 0 nil input))))))

  (defun case-lambda-1 (clauses index cnt tmps input)
    "Inner function for `case-lambda'"
    (if (null clauses) '(error "case-lambda match failure")
      (pcase-let* ((`(,first . ,rest) clauses)
                   (`(,arglist . ,body) first))
        (let* ((rvar (cadr (memq '&rest arglist)))
               (args (if (not rvar) arglist (nbutlast arglist 2)))
               (len (length args)))
          (if (<= len index)
              (if (not rvar)
                  (let ((res (case-lambda-1 rest index (1+ cnt) tmps input)))
                    (if (not (and (= cnt 0) (= len 0))) res
                      `(if (null ,input) (progn ,@body) ,res)))
                `(apply #'(lambda ,@first) (append (list ,@tmps) ,input)))
            (let* ((new-tmps (cl-loop repeat (- len index) collect (gensym)))
                   (params (append tmps new-tmps))
                   (result (if (not rvar) (case-lambda-1 rest len (1+ cnt) params input)
                             `(apply #'(lambda ,@first) (append (list ,@tmps) ,input)))))
              (named-let f ((i index) (ls (reverse new-tmps))
                            (r `(if (null ,input)
                                    (let (,@(cl-mapcar #'list args params)) ,@body)
                                  ,result)))
                (if (= i len)
                    (if (not (zerop cnt)) r
                      `(if (null ,input) (error "case-lambda match failure") ,r))
                  (f (1+ i) (cdr ls)
                     (cond
                      ((= i index)
                       `(let ((,(car ls) (car ,input)))
                          (setq ,input (cdr ,input))
                          ,r))
                      (t
                       `(let ((,(car ls) (car ,input)))
                          (setq ,input (cdr ,input))
                          (if (null ,input) (error "case-lambda match failure")
                            ,r)))))))))))))

  ;; Local Variables:
  ;; read-symbol-shorthands: (("c-" . "case-lambda-"))
  ;; End:
#+end_src

Gemini çš„è¯„ä»·æ˜¯ã€Œç›¸æ¯”è¿­ä»£å¼çš„å®žçŽ°å¯è¯»æ€§å¥½ä¸äº†å¤šå°‘ã€ï¼Œä¸è¿‡æˆ‘æƒ³ä¼šé€’å½’çš„äººåº”è¯¥å¾ˆå®¹æ˜“çœ‹æ‡‚å§ï¼ˆç¬‘ï¼‰ï¼Œè€Œä¸”æ•´ä¸ªä»£ç ä¸è¿‡ 60 è¡Œï¼Œä»£ç è¶ŠçŸ­å°±è¶Šå¥½ç†è§£ã€‚

=c--ensure-proper-arglist= å’Œ =case-lambda= æ‰€å®žçŽ°çš„åŠŸèƒ½åŸºæœ¬ä¸Šå’Œä¸Šé¢æåˆ°çš„å‘½ä»¤å¼å®žçŽ°æ²¡æœ‰å¤ªå¤§åŒºåˆ«ï¼Œæˆ‘çš„å®žçŽ°çš„é‡ç‚¹åœ¨ =case-lambda-1= è¿™ä¸ªå‡½æ•°ä¸Šã€‚åœ¨å®ƒçš„å‚æ•°ä¸­ï¼Œâ€‹=index= è¡¨ç¤ºå½“å‰å·²ç»ä»Žè¾“å…¥ä¸­å–åˆ°çš„å‚æ•°ä¸ªæ•°ï¼Œâ€‹=cnt= è¡¨ç¤ºå½“å‰çš„å­å¥åºå·ï¼Œâ€‹=tmps= è¡¨ç¤ºæ‰€æœ‰çš„ä¸´æ—¶ç¬¦å·ï¼Œâ€‹=input= è¡¨ç¤ºå‡½æ•°è°ƒç”¨ä¸­èŽ·å–çš„å‚æ•°åˆ—è¡¨ã€‚

å®žé™…ä¸Šï¼Œæˆ‘ä»¬ä¸éœ€è¦å¤ªå¤šçš„å˜é‡æ¥è®°å½•çŠ¶æ€ï¼Œç”šè‡³ä¹Ÿä¸éœ€è¦åœ¨å¼€å§‹æž„é€ å‰èŽ·å–å­å¥çš„å‚æ•°ä¿¡æ¯ï¼Œè¿™äº›å®Œå…¨å¯ä»¥åœ¨é€’å½’è¿‡ç¨‹ä¸­å®Œæˆï¼š

#+begin_src elisp
  (pcase-let* ((`(,first . ,rest) clauses)
               (`(,arglist . ,body) first))
    (let* ((rvar (cadr (memq '&rest arglist)))
           (args (if (not rvar) arglist (nbutlast arglist 2)))
           (len (length args)))
      ...))
#+end_src

è¿™ä¸€ä»£ç çš„ä½œç”¨æ˜¯èŽ·å–å½“å‰å­å¥ =first=â€‹ï¼Œä»¥åŠå®ƒçš„å‚æ•°åˆ—è¡¨ =arglist= å’Œå‡½æ•°ä½“ =body=â€‹ï¼Œç„¶åŽå°è¯•èŽ·å–å‰©ä½™å‚æ•°å˜é‡ =rvar= å’Œä¸å«å‰©ä½™å‚æ•°çš„å›ºå®šå‚æ•°åˆ—è¡¨ =args= åŠå…¶é•¿åº¦ã€‚æŽ¥ç€ï¼Œæˆ‘ä»¬ä¼šåˆ¤æ–­å½“å‰å­å¥çš„å›ºå®šå‚æ•°æ˜¯å¦å°äºŽå·²ä»Žè¾“å…¥ä¸­èŽ·å–çš„å‚æ•°æ•°é‡ï¼Œå¦‚æžœæ˜¯åˆ™è¯´æ˜Žè¯¥å­å¥çš„å‚æ•°æ•°é‡å°äºŽæŸä¸€ä¹‹å‰å‡ºçŽ°è¿‡çš„å­å¥ï¼Œè¿™ç§æƒ…å†µä¸‹è¯¥å­å¥æ˜¯è¦è¢«èˆå¼ƒçš„ï¼Œå°±åƒå‘½ä»¤å¼å®žçŽ°çš„ä¸€æ ·ï¼š

#+begin_src elisp
  (if (<= len index)
      (if (not rvar)
          (let ((res (case-lambda-1 rest index (1+ cnt) tmps input)))
            (if (not (and (= cnt 0) (= len 0))) res
              `(if (null ,input) (progn ,@body) ,res)))
        `(apply #'(lambda ,@first) (append (list ,@tmps) ,input)))
    ...)
#+end_src

å½“ç„¶ä½ å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„é€»è¾‘æ˜Žæ˜¾æ¯”æˆ‘æè¿°çš„è¦å¤æ‚ä¸€ç‚¹ï¼Œå¦‚æžœè¯¥å­å¥ä¸å«å‰©ä½™å˜é‡ï¼Œä½†å®ƒæ˜¯ç¬¬ä¸€ä¸ªå­å¥ä¸”å‚æ•°æ•°é‡ä¸º 0ï¼Œé‚£ä¹ˆå®ƒéœ€è¦ä¸€ç‚¹è¡¨è¾¾å¼æ¥å¤„ç†è¾“å…¥å‚æ•°ä¸º 0 çš„æƒ…å†µï¼›å¦‚æžœå®ƒå«æœ‰å‰©ä½™å˜é‡ï¼Œé‚£æˆ‘ä»¬ç›´æŽ¥ä½¿ç”¨ =apply= é…åˆå·²æœ‰ä¸´æ—¶å˜é‡å’Œè¢«ä¿®æ”¹è¿‡çš„è¾“å…¥é‡æ–°ç»„åˆå¾—åˆ°å®Œæ•´å‚æ•°æ¥è°ƒç”¨å®ƒå³å¯ã€‚

æŽ¥ä¸‹æ¥æ˜¯æ­£å¸¸çš„å¤„ç†è¿‡ç¨‹ï¼Œå½“å½“å‰å­å¥å›ºå®šå‚æ•°æ•°é‡å¤§äºŽä¹‹å‰æœ€å¤§å‚æ•°æ•°é‡çš„å­å¥æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯èƒ½éœ€è¦ä»Žå°‘åˆ°å¤šçš„å‚æ•°èŽ·å–è¿‡æ¸¡è¿‡ç¨‹ï¼ŒäºŽæ˜¯æˆ‘ä»¬ç”Ÿæˆäº†æ–°çš„ä¸´æ—¶ç¬¦å·ï¼Œæž„å»ºæ–°çš„ä¸´æ—¶ç¬¦å·è¡¨å¹¶æ ¹æ®å½“å‰å­å¥æ˜¯å¦å«æœ‰å‰©ä½™å˜é‡æ¥å†³å®šæ˜¯å¦ç»§ç»­é€’å½’è¿‡ç¨‹ï¼š

#+begin_src elisp
  (let* ((new-tmps (cl-loop repeat (- len index) collect (gensym)))
         (params (append tmps new-tmps))
         (result (if (not rvar) (case-lambda-1 rest len (1+ cnt) params input)
                   `(apply #'(lambda ,@first) (append (list ,@tmps) ,input)))))
    ...)
#+end_src

æŽ¥ä¸‹æ¥æ˜¯ä¸æ–­æ ¹æ®å·²æœ‰ä¸´æ—¶ç¬¦å·æ•°é‡ä¸Žéœ€è¦çš„ç¬¦å·æ•°é‡è¿›è¡Œè¿­ä»£çš„è¿‡ç¨‹ï¼Œä¸è¿‡æˆ‘ä½¿ç”¨äº† =name-let= åšå°¾é€’å½’æ¥å¼ºè¡Œå†™æˆé€’å½’äº†ï¼š

#+begin_src elisp
  (named-let f ((i index) (ls (reverse new-tmps))
                (r `(if (null ,input)
                        (let (,@(cl-mapcar #'list args params)) ,@body)
                      ,result)))
    (if (= i len)
        (if (not (zerop cnt)) r
          `(if (null ,input) (error "case-lambda match failure") ,r))
      (f (1+ i) (cdr ls)
         (cond
          ((= i index)
           `(let ((,(car ls) (car ,input)))
              (setq ,input (cdr ,input))
              ,r))
          (t
           `(let ((,(car ls) (car ,input)))
              (setq ,input (cdr ,input))
              (if (null ,input) (error "case-lambda match failure")
                ,r)))))))
#+end_src

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯å½“ ~(= i index)~ æ—¶æˆ‘ä»¬éœ€è¦ç”Ÿæˆä¸ä¸€æ ·çš„ä»£ç ï¼Œè¿™æ˜¯å› ä¸ºå®ƒæ˜¯ã€Œæœ€å†…å±‚ã€çš„ä»£ç ï¼Œç›´æŽ¥ä¸Ž =result= å¯¹æŽ¥ï¼Œè€Œ =result= å·²ç»å«æœ‰ =(if (null ,input))= çš„åˆ¤å®šäº†ã€‚

å¤§æ¦‚å°±æ˜¯è¿™æ ·ï¼Œå¦‚æžœæ˜¯ä¼š Lisp çš„åŒå­¦åº”è¯¥èƒ½è½»æ¾ç†è§£å§ã€‚

* åŽè®°

è€å®žè¯´ï¼Œæˆ‘å¯¹ä¸€å¼€å§‹çš„ä»£ç å¹¶ä¸æ€Žä¹ˆæ„Ÿå…´è¶£ï¼Œä½†çŽ°åœ¨çœ‹æ¥ä¹Ÿç®—ä¸é”™çš„è¿­ä»£æ”¹é€’å½’å®žçŽ°ç»ƒä¹ ã€‚è¿™æ ·çš„æ–‡ç« å†™èµ·æ¥æ¯”å¼•ç»æ®å…¸çš„è½»æ¾å¤ªå¤šäº†ã€‚
