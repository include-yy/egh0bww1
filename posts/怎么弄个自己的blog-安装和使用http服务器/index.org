#+SETUPFILE: ../../setup.org
#+TITLE: 怎么弄个自己的 blog —— 安装和使用 http 服务器
#+TITLE: @@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly93d3cucGl4aXYubmV0L2FydHdvcmtzLzYxMzY1MDMw.jpg" alt="load failed"></div>@@
#+DATE: [2022-10-13 Thu 23:22]
#+TAGS: essay

在上一篇文章中我提到了 blog 最后是以 HTML 页面的形式呈现的，所以我们还是需要一个 HTTP 服务器。虽然我们不一定要将 blog 部署到远程服务器上，毕竟本地访问网页也是没问题的，但是 blog 不发出来那还叫 blog 吗？当然我也知道某些网站会提供静态页面托管的功能，不过为了最一般情况的考虑，我们还是从 HTTP 服务器说起。之后我也会介绍一些静态托管的网站，比如 github-pages，cloudflare worker 等。

你可能听说过 LAMP 之类的词，LAMP 就是 Linux+Apache+Mysql+PHP 的缩写，它们四个组合起来提供网站服务。本文会涉及到它们中的三个，也就是 Linux，Apache 和 PHP，不过我会把 Apache 替换为 Nginx，之后也可能把 PHP 替换为 Node（我不会 PHP），这样一来 LAMP 就成了 LNMP 或 LNMN。

本文包括的内容如下：

- 操作系统的选择
- 从光纤到 HTTP 协议
- 安装与配置 Nginx
- 和网页相关的一些知识
- 安装和配置 PHP
- 下一步的工作

* 操作系统的选择

可用的操作系统还是很多的，比如 Windows Server，Linux 和 BSD 系列。Windows Server 我还没安装过，FreeBSD 我简单用过，但现在还不是很习惯，我最熟悉的还是 Linux，虽然我只敲过一些简单的 bash 命令和使用 =apt install= 装过一些常见的软件。

Linux 发行版少说也有上百个吧，就我了解的话比较常见的有 Ubuntu，RedHat，Debain，SUSE，CentOS（死了），Arch，Gentoo 等等。本文会使用 Ubuntu Server ，这是我最熟悉的 Linux 系统。如果你会一点 Linux 也可以选择其他系统。

Ubuntu Server 的下载链接在这：[[https://ubuntu.com/download/server][Get Ubuntu Server]]，下载完成后就可以开始安装了。我不是太建议直接使用真正的远程服务器（毕竟要花钱，不过 AWS 也有免费机器...），也不是太建议在真机上装（镜像刻录啥的好麻烦...），我推荐装在虚拟机上，比如 VMware，分配 2 个核心，2 GB 内存和十几个 GB 的硬盘就可以了。装在虚拟机上主要有两个好处，一是执行一些关键操作前可以保存快照，这样弄错了也可以快速回退，二是从宿主机器传输文件到虚拟机的速度很快，这样不用太关心网络问题。

在具体的安装过程中我推荐使用最小安装（minimal），这样装完的系统基本上啥也没有，非常干净，也就不会出现各种各样奇怪的错误。不过这样装完后需要自己安装一些基础功能，比如 vim，lsof 等等。

我使用的是 Ubuntu Server 22.04.1 LTS，我录制了一个[[https://www.bilibili.com/video/BV1De4y1E7VZ/][视频]]来展示它在 VMware 中的安装过程。完成安装后你就得到了几乎全裸的 Ubuntu Server。对于咱们国内用户，我建议首先配置好 apt 镜像源，下面几个镜像源都给出了教程，这里就不过多说明了（由于这时候你还没有编辑器用，所以可能有点小困恼，准备好 echo 和 cat 吧）。

- [[https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/][tsinghua ubuntu 镜像使用帮助]]
- [[https://mirrors.ustc.edu.cn/help/ubuntu.html][ustc ubuntu 源使用帮助]]

如果你的主机中有本地代理服务器，可以让虚拟机直接使用，通过修改 =/etc/apt/apt.conf.d/proxy.conf= 中的内容来让 apt 使用代理，也许就不需要国内源了（笑），就像这样：

#+BEGIN_SRC conf
  Acquire::http::Proxy "http://192.161.145.14:8080";
  Acquire::https::Proxy "http://192.161.145.14:8080";
#+END_SRC

（如果你在系统安装过程中指定了代理就不需要上面的配置，在 =/etc/apt/apt.conf.d/= 中会有一个代理配置文件）

配置好 apt 后就可以执行一些更新操作了：

#+BEGIN_SRC bash
  sudo apt update
  sudo apt upgrade
#+END_SRC

执行完上面两条指令后我们就可以安装一些基础软件了：

#+BEGIN_SRC bash
  # 编辑器
  sudo apt install vim
  sudo apt install nano

  # ping
  sudo apt install iputils-ping

  # lsof
  sudo apt install lsof

  # net-tools
  sudo apt install net-tools
#+END_SRC

现在，我们有了最基本的编辑能力（vim 和 nano 喜欢哪个用哪个吧），可以为我们的虚拟机创建一个快照了，LAMP 中的 L 准备的差不多了。

此时的虚拟机是没有启用防火墙的，这样我们后续的操作会方便一些。如果你不喜欢 VMware 的界面的话，可以使用 SSH 工具远程连接虚拟机，比如 Xshell，MobaXterm 之类的软件。我在系统安装过程中指定了安装 SSH 服务器。使用 =hostname -I= 即可获取虚拟机的 ip 地址。

| [[./1.JPG]] |

* 从光纤到 HTTP 协议

如果你像我一样只知道 HTTP 是一个应用层协议的话，那么这一节对你了解下一节的 HTTP 服务器应该是有所帮助的（老实说我也是现学现卖，这一节大可以直接跳过，软件的东西我讲硬件干啥）。我假设你已经知道了什么是 OSI 模型和什么是 TCP/IP 协议栈。我们使用所谓的五层分法，即物理层，数据链路层，网络层，传输层和应用层。至于什么是网络协议，不严谨地说可以简单理解为甲乙方合同。

不知道你是怎么看计算机网络的分层的，这里给出我的看法：网络的分层是为了分摊任务，更书面点的说法也许是系统复杂度分配与模块化。每一层 *只需关注本层协议即可* ，相邻层间的互动只有发送和接收接口。某一层为它的上一层提供服务，并使用下一层为它提供的服务。在发送数据时，某一层只需要按照该层协议对（也许是上一层来的）数据进行包装然后丢给下一层（最多到物理层），其余的就不用管了；某一层在接收数据时，只需接收（下一层来的）数据并按照协议取出其中的内容即可（也许要丢给上一层）。当然网络分层不是说想分就分的，每一层都有对应的问题需要解决，这需要巨量的资金和研究投入，而且每一层真正要做的工作也不会像上面描述的那么简单。

除了说为每层分配不同任务转移了复杂度这个好处之外，分层的模块化带来的好处就是接口与实现分离。在保证接口功能不变的情况下我们可以对实现进行修改而不影响网络系统中的其他层的正常功能，这样就实现了各功能模块的分隔。这有点像编程里的抽象化，将系统分割为几个抽象层以便于分开处理。当然引入抽象不可避免地会带来性能损失或更多的资源占用（我不太相信 zero cost abstraction，或者说我认为在真实世界中很难真正做到这一点），但是良好的抽象带来的好处是远大于这点损失的。

这里咱们简单介绍下计算机网络中各层的工作，为下面做些简单铺垫。物理层和数据链路层我只懂一点 *以太网* 相关的东西，所以下面只会简单提到以太网。

物理层提供设备之间的通信通路，规定了一系列传输媒体与对应的传输信号的各种特性（注意信号与数据的区别哟），它将数据的一个个比特从一个节点发送到下一节点。我比较了解的物理层收发模块只有 PHY 芯片，它是对物理层协议 IEEE-802.3 的硬件实现。它为数据链路层提供数据收发服务，以及一些其他的功能。MAC（数据链路层的一个子层）芯片到 PHY 芯片的接口有很多种，如 MII/RMII/GMII/RGMII/SGMII 等等，MAC 芯片通过接口将以太网帧数据传输给 PHY 芯片，再由 PHY 芯片转换为串行信号沿介质传输，到达另一设备后由另一 PHY 芯片将信号转换为数据通过接口交给 MAC 芯片处理。因为涉及到模数转换，一般 PHY 芯片都是模数混合电路。

数据链路层建立在物理层之上，为同一网段（network segment）中的两节点提供通信服务。它使用物理层服务直接发送/接收数据，不关心数据以何种介质和信号传输。

光是说说的话是不能对所学知识有足够清晰的认识的，写到这里我不禁心血来潮想用 elisp 完整实现一个高度简化的计算机网络系统，里面包含几十台计算机，具有由交换机连接的局域网和由路由器连接的局域网组成的网络，每台计算机上可以挂载使用不同“端口”的 elisp 函数，提供 TCP 和 UDP 协议，支持极简应用层协议，等等......，想的我不禁流口水，不过实现难度实在是有些大，先挖个巨坑在这里。我们用一张图和一段非常简单的代码来说明一下网络的分层工作方式：

我们先从计算机收发网络数据开始说起吧，下一节简单介绍从物理层到网络层的简单知识。

** 计算机是怎么收发网络数据的

这里咱们只关心计算机是怎么接收和发出数据，至于数据是经过了多少路由或交换机的中转就不管了。我们关注的部分如下图所示：

| [[./2.JPG]] |

如上图所示，如果使用有线传输的话，网络数据需要通过光纤或铜缆到达与计算机连接的有线网卡，如果是无线传输则通过电磁波传输到无线网卡。

*** 服务器中的应用如何收发消息

当我们点击窗口或是敲击键盘时，应用程序能够对接收这些输入并做出响应。消息是由操作系统获取放入系统消息队列中再分派到各对应应用中的。当我们向服务器发送消息时，服务器是否有类似的机制呢？换言之，是否有一种机制，在计算机接收到网络信息时能够根据某种名字或者标识将信息分派给各应用程序。答案当然是肯定的，这一种机制被称为端口（port）。
