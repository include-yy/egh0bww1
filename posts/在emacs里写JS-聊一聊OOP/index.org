#+SETUPFILE: ../../setup.org
#+TITLE: 在 emacs 里写 JS —— 对 JS 的简单介绍
#+TITLE: @@html:<div class="yyheadimg"><img src="./aHR0cHM6Ly90d2l0dGVyLmNvbS9DaWxvUmFua28vc3RhdHVzLzE0MDE3MDA0NDI2MTkzNTEwNDU=.jpg" alt="load failed"></div>@@
#+DATE: [2022-10-19 Wed 15:28]
#+TAGS: emacs js

在简单介绍 JS 的 OOP 之前咱还是介绍下啥是 OOP 先，毕竟我没怎么写过面向对象的代码。你大可认为写这篇文章的时候我是个 OOP 白痴，然后跳过下一节中的大放厥词。我写这段的目的是给 *自己* 找一个说得过去的 OOP 认识。

如果你和我一样是从 C 开始学的编程，那么接触到的第一门所谓的 OOP 语言应该是 C++。很可惜的是我在学习 C++ 这件事上屡战屡败，到现在都没有看完 C++ Primer 第五版，我可是从二〇一九年就开始尝试了（笑）。不知道是不是学不会 C++ 这件事让我有点面向对象恐惧症，我现在还没有系统地学过任何的主流 OOP 语言，我的 Python 水平仅有读完官方 Tutorial 的水平，而且不会写类，我还尝试过 Java，但没写几行就放弃了。现在是看到 =class= 关键字我就不是很舒服，PTSD 了属于是。借着学习 emacs 和 javascript 的机会，看看这一次能否再次认识一下 OOP，让我摆脱掉 OOP PTSD。这一节我会参考一些资料，介绍一下 OOP 三要素（封装继承多态）出现之前的 OOP，看看最开始的 OOP 是什么样的。

和 JS 一样，我对 OOP 的认识约等于零，而且我也没有参加软件开发的经验，也就是说如果你在下文中发现了什么不对劲的地方的话，你很可能是对的。由于时间和能力问题，我不可能完成对整个 OO 范式发展的描述和分析，这大概够写一堆书的。OO 背后涉及到了很多计算机理论的知识，下文我会简单介绍一下粗浅的内容。原本我是准备在使用过市面上主流的 OOP 语言后再专门写一篇总结性的文章，但是实在太费事了，遂放弃，咱还是放弃整体求局部吧，一个足够简单的模型也许更易于认识，就像 λ 一样。在下文中我会使用 C++/CL/Elisp/Racket 作为基于类的 OO 代表，与 JS 作为基于原型的 OO 代表来举例。如果你不太了解 Lisp 系语言的话，C++ 代码应该比较容易懂。

最后声明一下，由于个人原因，我对于 OO 的态度并不怎么正面，所以下面内容整体可能对 OO 呈负面态度，当然我会尽量保证引用内容的准确性并给出来源。如果文中内容令你不快，可跳至下一节或 =Alt+F4= 或右划，或者给出你的观点。

** OOP 简史

OOP 的全称是 Object Oriented Programming，即面向对象编程，也叫物件导向程式设计，强调将程序看作不同对象的调用交互过程。按我的理解，将程序看作对象的交互就是要在对象与对象之间划分出边界来，让每个对象负责好它自己的那一部分，这有点像社会中的人，只负责自己的吃喝拉撒。所以 *封装* 就是 OOP 的一大特点，作为对象的你把握好三寄吧原则就好：你寄吧谁啊，我寄吧谁啊，他寄吧谁啊。既然有了边界，那么两对象之间也需要交流机制，通过某种标准的方式来进行交互，这在 OOP 中被称为 *消息* 。 *封装* 与 *消息* 就是我对 OOP 的认识了，至于封装继承多态抽象啥的去他的吧。就这么看的话，咱写 OOP 的代码并不需要一门声称支持 OOP 的语言，下面我们用闭包来捏个计数器对象玩玩：

#+BEGIN_SRC javascript
    let Ytimer = function (init_value) {
	let val = init_value;
	this.get = function () { return val; };
	this.inc = function () { val = val + 1; return val; };
	this.dec = function () { val = val - 1; return val; };
    }

    let at = new Ytimer(10)

    at.get() // 10
    at.inc() // 11
    at.dec() // 10
#+END_SRC

上面的对象提供了三个方法，分别是获取计数，增加计数和减少计数，调用这些方法就像是发消息给这个对象，同时你也没有除 =get= 外的其他方法来获得当前计数器的值，这就非常的封装，非常的 OO。使用消息来达到完成某种动作的目的就意味着 *抽象* ，发号施令者把简单的消息告诉了实施者，再由实施者来完成，这也算是由少（消息）到多（动作）的过程，嗯，这很抽象。

我们上面拿函数来实现了消息机制，看上去比函数抽象也没高级到哪里去，这就要看和谁相比了：对 C 这种不允许匿名函数的语言来说，要想拿函数名字当作消息名有点困难，如果我们想给获取一堆对象的“长度”，那我们要给每个.
