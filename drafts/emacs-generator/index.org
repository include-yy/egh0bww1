#+SETUPFILE: ../../setup.org
#+FILETAGS: emacs

#+TITLE: emacs generator 使用及实现介绍
#+DATE: [2023-03-25 Sat 20:20]

本文简单介绍了 emacs 中的 generator 的使用方法，并介绍了它的实现方式。由于这个 generator 是通过 CPS 实现的，本文也就不可避免地涉及到一些 CPS 相关的知识，所以希望读者对 Scheme 或 Racket 有一些简单的了解，我可能会使用它们来举一些非常简单的例子。

只想了解 generator 用法的读者只需要阅读本文的前两节。如果读者想要完全看完这篇文章，可能需要以下知识：

- 菜鸟级别的 Python，JavaScript 语言知识
- 一点 Scheme 语言经验，或者说写过一点 Scheme
- 了解过一点点 CPS（continuation passing style）
- 听说过 yin wang（笑）

本文的环境为 emacs 28.1 x86_64 on Windows。

{{{toc}}}

* 什么是 generator

/talk is cheap, show me the code -- Linus Torvalds/

/废话少说，放码过来~/

下面是两个 generator 的例子，它们分别使用了 Python 和 JavaScript，算是我比较熟悉的两门语言了：

#+BEGIN_SRC python
  def fib():
      a = 0
      b = 1
      while True:
	  a, b = b, a + b
	  yield a

  a = fib()

  for i in range(0, 9):
      print(next(a))
  # 1 1 2 3 4 8 13 21 34 (with newlines)
#+END_SRC

下面是一个简单的 JS generator 例子，摘自 MDN 文档：

#+BEGIN_SRC js
  const foo = function*() {
    yield 'a';
    yield 'b';
    yield 'c';
  };

  a = foo()

  a.next()
  // {value: 'a', done: false}
  a.next()
  // {value: 'b', done: false}
  a.next()
  // {value: 'c', done: false}
  a.next()
  // {value: undefined, done: true}

  let str = '';
  for (const val of foo()) {
      str = str + val;
  }

  console.log(str);
  // Expected output: "abc"
#+END_SRC

不管是 Py 还是 JS，在上面的代码中都使用了 =yield= 关键字，它们的作用看上去和 =return= 没什么区别，不过比较有意思的是在 =next= 调用“返回”后，caller 再次对对象调用 =next= 时还能够回到 =yield= 表达式的位置并继续执行。这上面的函数（ =fib= 和 =foo= ）叫做 *generator* （也就是生成器）。

当然了，学过 Py 和 JS 的你应该知道 generater 只是一种 *iterator* （即迭代器）的方便写法罢了，上面的代码我们可以轻易使用 iterator 来实现：

#+BEGIN_SRC python
  class fib:
      def __init__(self):
	  self.a = 0
	  self.b = 1
      def __iter__(self):
	  return self
      def __next__(self):
	  self.a, self.b = self.b, self.a+self.b
	  return self.a

  a = fib()

  for i in range(0, 9):
      print(next(a))
#+END_SRC

在上面这个实现中，我们在对象中保存了当前 =a= 和 =b= 的值，在下一次 =next= 调用时就可以使用它们，这样就让 =fib= 的求取 *延续* 了下去。相比于自己手动构建 iterator，使用 generator 的好处是不用 *显式* 记录当前状态供下次调用使用，直接使用 =yield= 即可。以下是一些语言文档中对 generator 的描述：

#+BEGIN_QUOTE
A generator is a function that produces a potentially-infinite stream of values. Each time the function produces a value, it suspends itself and waits for a caller to request the next value.

-- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Generators.html][Elisp manual 11.6 Generators]]

A function which returns a generator iterator. It looks like a normal function except that it contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the next() function.

Usually refers to a generator function, but may refer to a generator iterator in some contexts. In cases where the intended meaning isn’t clear, using the full terms avoids ambiguity.

-- [[https://docs.python.org/3/glossary.html#term-generator][Python documentation generator]]

Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous.

When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.

-- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators][MDN Generator functions]]
#+END_QUOTE

从以上描述来看，elisp 强调了可由 generator 生成无穷流，而且 generator 在执行到某一点时会挂起并等待 caller 的下一次请求。Python 强调的是可通过 =yield= 得到有用的可用于循环的序列，而 JS 中则表示我们可以使用 generator 方便地实现一些迭代算法。总结一下的话就是：generator 允许我们保留某一点的执行状态，并在需要时返回以继续执行。

维基百科中对 generator 的定义如下：

#+BEGIN_QUOTE
In computer science, a generator is a routine that can be used to control the iteration behaviour of a loop.

Generators can be implemented in terms of more expressive control flow constructs, such as coroutines or first-class continuations. Generators, also known as semicoroutines, are a special case of (and weaker than) coroutines, in that they always yield control back to the caller (when passing a value back), rather than specifying a coroutine to jump to.

[[https://en.wikipedia.org/wiki/Generator_(computer_programming)][Generator (computer programming) - Wikipedia]]
#+END_QUOTE

这段引文中将 generator 称为 semicoroutine（半协程），即认为 generator 是一种特殊（弱化的）coroutine，因为它只能将控制权返还给 caller 而不是其他 coroutine（因此也叫做非对称协程）。同时它也说明了 generator 可由 coroutine 和 first-class continuation 来实现。由于能力精力所限，这里我就不介绍什么是 coroutine 了，至于 first-class continuation 也在文章的开头假设读者已经掌握了，如果读者对这些概念感兴趣的话，下面的一些文章可供阅读：

- [[https://egh0bww1.com/posts/2020-08-11-scheme-callcc/][Scheme 的 call/cc]]
- [[https://coolshell.cn/articles/10975.html][一个“蝇量级” C 语言协程库]]

* emacs generator 的使用

整个 generator 文档只有一页，就使用上来说 emacs 的 generator 并不复杂，只是几个函数和宏而已。

我们可以使用 =iter-defun= 来定义 generator，它的用法就像普通的 =defun= 一样，只不过调用它并不会直接对 body 求值，而是返回一个 iterator 对象。通过对这个 iterator 调用 =iter-next= 我们可以获取它其中的值，在 body 结束后，再次调用 =iter-next= 时会触发 =iter-end-of-sequence= 信号，来表示 iterator 结束了。

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (iter-defun foo123 ()
    (iter-yield 1)
    (iter-yield 2)
    (iter-yield 3))

  (setq a (foo123))
  (iter-next a) => 1
  (iter-next a) => 2
  (iter-next a) => 3
  (iter-next a) => Debugger entered--Lisp error: (iter-end-of-sequence)

  (iter-defun foo+1 ()
    (let ((a (iter-yield 1)))
      (iter-yield (+ a 1))))

  (setq b (foo+1))

  (iter-next b) => 1
  (iter-next b 30) => 31
  (iter-next b) => Debugger entered--Lisp error: (iter-end-of-sequence)
#+END_SRC

注意上面的 =lexical-binding= ，只有在开启词法作用域的情况下才能够使用 generator。除了使用 =iter-defun= 外，我们也可以使用 =iter-lambda= 来创建匿名 generator：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (setq a (funcall (iter-lambda ()
		     (iter-yield 1)
		     (iter-yield 2)
		     (iter-yield 3))))

  (iter-next a) => 1
  ;;...
#+END_SRC

代码示例中的 =iter-yield= 和上一节中的 =yield= 关键字功能类似，都是从当前点回到调用处，没什么好说的。不过 generator.el 还提供了一个叫做 =iter-yield-from= 的宏，它可以从其他 iterator 获取迭代值来作为当前迭代器的 =yield= 值：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (setq a (iter-lambda ()
	    (iter-yield 1)
	    (iter-yield 2)
	    (iter-yield 3)))

  (setq b (iter-lambda (it)
	    (iter-yield 4)
	    (iter-yield-from it)
	    (iter-yield 5)))

  (setq c (funcall a))
  (setq d (funcall b c))

  (iter-next d) => 4
  (iter-next d) => 1
  (iter-next d) => 2
  (iter-next d) => 3
  (iter-next d) => 5
  (iter-next d) => Debugger entered--Lisp error: (iter-end-of-sequence)
#+END_SRC

如果我们要手动调用 =iter-next= 的话，那么我们也需要处理 =iter-end-of-sequence= 这个 signal。generator.el 为我们提供了一个 =iter-do= 宏，帮我们进行了处理：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (setq a (iter-lambda ()
	    (iter-yield 1)
	    (iter-yield 2)
	    (iter-yield 3)))

  (setq b nil)
  (iter-do (i (funcall a))
    (push i b))
  b => (3 2 1)
#+END_SRC

参考文档，如果我们想手动处理这个 signal 的话，我们可以这样做：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (setq a (iter-lambda ()
	    (iter-yield 1)
	    (iter-yield 2)
	    (iter-yield 3)
	    4))

  (setq flag t)
  (setq it (funcall a))
  (while flag
    (condition-case x
	(iter-next it)
      (iter-end-of-sequence
       (progn (print x)
	      (setq flag nil)))))
  => print (iter-end-of-sequence . 4)
#+END_SRC

当然，我们也可以使用 =cl-loop= 中的 =iter-by= 关键字来处理 iterator：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (setq a (iter-lambda ()
	    (iter-yield 1)
	    (iter-yield 2)
	    (iter-yield 3)))

  (cl-loop for n iter-by (funcall a)
	   collect n)
  => (1 2 3)
#+END_SRC

最后值得一说的是 =iter-close= 这个函数，根据文档的描述，如果 iterator 在一个 =unwind-protect= 挂起且变得不可达（unreachable，指没法指向它了），那么 emacs 会在一次 gc 后执行 unwind 的 handler 部分。为了让 handler 在 gc 之前执行，我们可以使用 =iter-close= 关闭 iterator。文档中提到在 =unwind-protect= 的 =unwindforms= 部分使用 =iter-yield= 是不行的。

* CPS 与 CPS 变换

正如开头所说，由于 generator.el 的实现是通过 CPS 的，这里我们也不得不学习一些 CPS 的相关知识。我打算写一个非常简单的 CPS 变换函数来帮助读者了解 CPS 变换是如何进行的。先从什么是 continuation 开始吧。

所谓 continuation 就是计算的延续，或者说是我们在计算之后 *下一步要做什么* 。举个不太严谨的例子，如果某人吃完午饭后有刷牙的习惯（我没有），那么刷牙就成了午饭的延续：

#+BEGIN_SRC elisp
  (defun eat-lunch (food knife do-sth)
    (handle knife)
    (eat food)
    (funcall do-sth me))

  (defun brush-teeth (person)
    (brush-up)
    (brush-down))

  (eat-launch '(banana apple) '✓ 'brush-teeth)
#+END_SRC

实际上上面的表达是比较过程式的，吃午饭和刷牙的子步骤默认按照顺序结构顺序执行了，我们可以把它们表达的更加函数式一点：

#+BEGIN_SRC elisp
  (defun eat-lunch* (food knife do-sth)
    (handle* knife
	     (lambda ()
	       (eat* food
		     (lambda ()
		       (funcall do-sth me
				(lambda () nil) ; do nothing
				))))))

  (defun brush-teeth* (person next)
    (brush-up* (lambda ()
		 (brush-down* (lambda ()
				(funcall next))))))
#+END_SRC

上面的带 =*= 函数是对原函数的一点变化，就像这样：

#+BEGIN_SRC elisp
  (defun org (a b)
    (+ a b))

  (defun org* (a b k)
    (funcall k (org a b))
#+END_SRC

通过这样的变化，我们就将过程式中隐含顺序执行 *显式* 地表达了出来。上面带 =*= 函数中的最后一个参数就是在完成函数本身任务后接下来要执行的函数，被称为 continuation。之所以 CPS 叫 CPS，就是因为它通过这种暴露 continuation 的方式显式表达了控制流。比如我们想表达一个人活了 100 年，我们可以使用下面的代码：

#+BEGIN_SRC elisp
  ;; live 100 years

  (defun wake-up () nil)
  (defun eat () nil)
  (defun sleep () nil)

  (let ((age 0))
    (while (< age 100)
      (wake-up)
      (eat)
      (sleep)
      (cl-incf age 1))
    (message "shin-de"))
  => "shin-de"
#+END_SRC

将上面的代码改成 CPS 的话可以是这样的：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (defun wake-up* (k) (funcall k))
  (defun eat* (k) (funcall k))
  (defun sleep* (k) (funcall k))
  (defun die () (message "shin-de"))

  (defun live (age k)
    (if (>= age 100)
	(funcall k)
      (wake-up*
       (lambda ()
	 (eat*
	  (lambda ()
	    (sleep*
	     (lambda ()
	       (live (+ age 1)
		     k)))))))))
  (live 0 'die)
  => "shin-de"
#+END_SRC

上面我对一些基础的运算没有进行变换，比如 =>== ，下面我对所有的运算都进行变换，来得到一个 fib 函数的 CPS 代码：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (defun fib (n)
    (cond
     ((= n 0) 0)
     ((= n 1) 1)
     (t
      (+ (fib (- n 1))
	 (fib (- n 2))))))

  (fib 30) => 832040

  (defun =* (a b k)
    (funcall k (= a b)))
  (defun +* (a b k)
    (funcall k (+ a b)))
  (defun -* (a b k)
    (funcall k (- a b)))

  (defun fib* (n k)
    (=* n 0
	(lambda (k1)
	  (if k1 (funcall k 0)
	    (=* n 1
		(lambda (k2)
		  (if k2 (funcall k 1)
		    (-* n 1
			(lambda (k3)
			  (fib* k3
				(lambda (k4)
				  (-* n 2
				      (lambda (k5)
					(fib* k5
					      (lambda (k6)
						(+* k4 k6
						    (lambda (k7)
						      (funcall k k7))))))))))))))))))

  (fib* 8 'identity) => 21
#+END_SRC

由于会爆栈，这个 CPS 变换后的 =fib*= 只能算到 =fib(8)= 。这个 =fib*= 并不完全等价于 =fib= ，在 =fib= 中我们并不知道 =fib(n-1)= 和 =fib(n-2)= 的运算顺序，但是在 =fib*= 中我显式指定了前者要在后者之前。也就是说，通过 CPS 变换，我们可以 *指定求值顺序* 。

读者有兴趣的话可以在 JS 中试着写一个这样的 =fib*= 函数出来。

** 如何实现 CPS 变换

在上一节中我们手动将 =fib= 函数变成了 CPS 的 =fib*= ，那么，能不能实现一个函数，它接受一段函数代码，并将其转换为 CPS 代码呢？那当然是有的，不过一般是在编译器中完成的。所幸 Lisp 系编程语言的一大特点就是代码即数据，所以我们可以方便地对代码进行变换并进行观察。由于 elisp 属 Lisp-2，需要区分变量和函数，这里我们使用更加方便的 Scheme/Racket 来编写代码，它不需要用到麻烦的 =funcall= 。

出于简单的考虑，我们进行 CPS 的语言就是 lambda 演算，所有的函数都是单参函数：

#+BEGIN_SRC bnf
  <λexp> :: <var>
	 | λ <var> . <λexp>
	 | ( <λexp> . <λexp> )
#+END_SRC

首先，对于简单的值，它的 CPS 变换结果就是在外面套一层 =lambda= ，比如对 =a= 的 CPS 变换就是 =(lambda (k) (k a))= 。

#+BEGIN_SRC elisp
  (CPS 'a) => (lambda (k) (k a))
#+END_SRC

对函数表达式，那自然也是外面包一层 =lambda(k)= ，但是我们不能仅对整个函数做变换，函数体也需要 CPS 变换，所以：

#+BEGIN_SRC elisp
  (CPS '(lambda (x) M))
  =>
  (lambda (k) (k (lambda (x) (CPS M))))

  (lambda (x) x)
  =>
  (lambda (k)
    (k (lambda (x)
	 (lambda (k)
	   (k x)))))
#+END_SRC

最后是对函数应用的变换，由于这里所有函数都是单参的，所以我们只需要分别对函数和参数进行 CPS 变换即可，然后把变换后得到的东西组合起来，再用 =lambda(k)= 包起来：

#+BEGIN_SRC elisp
  (CPS '(x y))
  =>
  (lambda (k)
    ((CPS x)
     (lambda (fun)
       ((CPS y)
	(lambda (arg)
	  ((fun arg) k))))))
  =>
  (lambda (k)
    ((lambda (k) (k x))
     (lambda (fun)
       ((lambda (k) (k y))
	(lambda (arg)
	  ((fun arg) k))))))
#+END_SRC

这一段可能有些烧脑，你可能会想为什么结果不是 =((CPS x) (CPS y))= ，这是因为经过 CPS 变换后函数多了一个 =k= 参数，我们需要额外的结构对它进行处理。

现在我们就完成了对基本 lambda 演算表达式的 CPS 变换，我们可以用 racket 的模式匹配简单写个 CPS 变换函数：

#+BEGIN_SRC scheme
  (define (mycps ls)
    (match ls
	   [(list a b)
	    `(lambda (k)
	       (,(mycps a)
		(lambda (fun)
		  (,(mycps b)
		   (lambda (arg)
		     ((fun arg) k))))))]
	   [(list a b c)
	    `(lambda (k) (k (lambda ,b ,(mycps c))))]
	   [p `(lambda (k) (k ,p))]))

  (mycps 'x) =>
  '(lambda (k) (k x))

  (mycps '(lambda (x) x)) =>
  '(lambda (k) (k (lambda (x) (lambda (k) (k x)))))

  (mycps '(x y)) =>
  '(lambda (k) ((lambda (k) (k x)) (lambda (fun) ((lambda (k) (k y)) (lambda (arg) ((fun arg) k))))))

  ((lambda (x) (x x)) (lambda (x) 1)) => 1

  (mycps '((lambda (x) (x x)) (lambda (x) 1))) =>
  '(lambda (k)
     ((lambda (k) (k (lambda (x) (lambda (k) ((lambda (k) (k x)) (lambda (fun) ((lambda (k) (k x)) (lambda (arg) ((fun arg) k)))))))))
      (lambda (fun) ((lambda (k) (k (lambda (x) (lambda (k) (k 1))))) (lambda (arg) ((fun arg) k))))))

  ((lambda (k)
     ((lambda (k) (k (lambda (x) (lambda (k) ((lambda (k) (k x)) (lambda (fun) ((lambda (k) (k x)) (lambda (arg) ((fun arg) k)))))))))
      (lambda (fun) ((lambda (k) (k (lambda (x) (lambda (k) (k 1))))) (lambda (arg) ((fun arg) k))))))
   (lambda (x) x)) =>
  1
#+END_SRC

当然，使用 elisp 的 =pcase= 也能很容易地实现上面的代码，这里还是用 elisp 实现一下做个补充。由于 elisp 没有尾递归优化，生成的代码没什么实际意义，更何况这是生成的 scheme-style 代码：

#+BEGIN_SRC elisp
  (setq lexical-binding t)
  (defun mycps2 (ls)
    (pcase ls
      (`(lambda ,x ,y)
       `(lambda (k) (k (lambda ,x ,(mycps2 y)))))
      (`(,appop ,apped)
       `(lambda (k) (,(mycps2 appop) (lambda (fun) (,(mycps2 apped)
						    (lambda (arg)
						      ((fun arg) k)))))))
      (sym `(lambda (k) (k ,sym)))))
#+END_SRC

就这样，我们实现了最基本的 lambda 演算 CPS 变换，不过光是变换一点用也没有，我们的目的是能够获取某一点的 continuation，而不是全部展开但是什么也不做。

** 
