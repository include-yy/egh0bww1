#+SETUPFILE: ../../setup.org
#+FILETAGS: emacs

#+TITLE: emacs 的加载机制
#+DATE: [2023-02-09 Thu 02:20]

#+ATTR_HTML: :class top-down-img
[[https://www.pixiv.net/artworks/38412472][file:0.jpg]]

在整完博客后，我猛然发现自己的 emacs 已经成为了一坨静静放在角落的旧物，我甚至都懒得动它。从最开始的单 .emacs 到有目录组织的 init.el，虽然层次感更强了，但在没有专门编写管理插件的情况下要修改配置还得一个一个打开分散的文件，大概这就是让我丧失折腾动力的原因。随着 use-package 加入 emacs 29，也许现在是时候重新拾起单文件配置的思想了。

本文（及可能的后续文章）是对 elisp manual 16, 41.1 和 emasc manual 49.4 的讲解和分析，以及对一些流行配置方案的介绍和个人评价。我只会分析我感兴趣的配置，对于某些 emacs “发行版”（比如 spacemacs，doom）我选择直接放弃（笑）。

本文使用的环境为 emacs 28.2 x86_64 on windows 11。

#+BEGIN_QUOTE
Try not to have too many nested folders. Keep your project flat, and have fewer files
(reminder: you can use nested modules).

Justification: The file system is a tree, but your code's dependencies are a graph.
Because of that, any file & folder organization is usually imperfect. While it's still
valuable to group related files together in a folder, the time wasted debating & getting
decision paralysis over these far outweight their benefits. We'll always recommend you to
Get Work Done instead of debating about these issues.

[[https://rescript-lang.org/docs/manual/latest/project-structure][rescript docs -- Project Structure]]
#+END_QUOTE

{{{toc}}}



* emacs 的 load 函数

加载一个 lisp 代码文件就意味着将文件中的内容带入 Lisp 环境中。Emacs 会寻找并打开文件，读取文本，对每一项进行求值，然后关闭文件。这样的一个文件也叫做一个 /Lisp 库/ 。

就像 =eval-buffer= 对 buffer 中所有表达式求值一样，函数 =load= 会对文件中的所有表达式进行求值。它们的不同之处在于 =load= 函数作用于文件而不是 Emacs 中的 buffer。被 load 的文件必须包含 Lisp 表达式，它可以是 elisp 源代码或字节编译代码。文件中的每个 form 被称为 /top-level form/ 。

整个 =load= 函数的文档很长，这一节的内容大部分都是我对文档内容的翻译，你可以通过访问 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/How-Programs-Do-Loading.html][elisp 文档]]来找到原文，或是在 emacs 中打开文档。我忽略掉了动态模块的加载，也许我会在之后的文章中进行介绍。除了 =load= 外我也会介绍一些基于 =load= 的加载函数。

=load= 的函数原型如下：

#+BEGIN_SRC elisp
(load filename &optional missing-ok nomessage nosuffix must-suffix)
#+END_SRC

首先， =load= 会尝试寻找 /filename.elc/ ，也就是 byte-compiled 的文件。如果它找到了文件且 emacs 带有 native-compilation 支持，那么 =load= 会尝试查找对应的 =.eln= 文件，如果找到了那么 load 会加载 =eln= 而不是 =elc= ，否则加载 =elc= 。如果不存在 =elc= 文件，那么 =load= 会查找名为 /filename.el/ 的文件，如果这个文件存在， =load= 会加载它。如果这些都没有找到， =load= 会尝试搜索不带后缀的 /filename/ ，并在该文件存在时加载它。

如果开启了 =auto-compression-mode= ，那么 =load= 在找不到文件并尝试其他文件名之前会查找该文件的压缩版本，并在压缩文件存在时解压缩加载。它通过添加 =jka-compr-load-suffixes= 中的后缀名到文件名来查找文件的压缩版本。 =jka-compr-load-suffixes= 必须是由字符串组成的表，它的默认值是 =(".gz")= 。

如果我们指定 =nosuffix= 为非 =nil= 值，那么 =load= 不会尝试对 /filename/ 添加 =el= 或 =elc= 后缀进行查找，我们就必须对 =filename= 参数指定带扩展名的文件名。如果 =auto-compression-mode= 开启的话， =load= 还是会使用 =jka-compr-load-suffixes= 来查找压缩版本。

如果 =must-suffix= 为非 =nil= 值，那么 =load= 会认定文件名必须以 =.el= 或 =.elc= 结尾（可能还有额外的压缩后缀），除非文件名显式指定了目录名。从参数位置和文档描述来看，这个选项是对 =nosuffix= 的加强。

如果 =load-prefer-newer= 为非 =nil= 值，那么 =load= 会选择最新的文件（ =elc=, =el= 等等）。在这种情况下 =load= 不会加载 =eln= 文件，即使它存在。

如果 =filename= 是相对位置文件名，比如 =foo=, =foo/bar.baz= ，那么 =load= 会使用 =load-path= 来搜索文件。它会将 /filename/ 加到 =load-path= 中的各个目录后面，然后加载第一个匹配的文件。如果 =default-directory= 也在 =load-path= 中， =load= 也会在当前目录搜索，要想这样做的话我们可以将 =nil= 添加到 =load-path= 中。当最终找到名字对应的文件和目录时，emacs 会将 =load-file-name= 设为文件的名字（文件的绝对路径）。

如果我们的 =el= 文件比对应的 =elc= 文件新，那么 Emacs 会提醒我们重新编译 =el= 文件。当加载 =el= 文件时， =load= 会使用 Emacs 打开文件时使用的编码行为来处理字符。

在加载未编译的文件时，Emacs 会尝试展开文件中所有的宏调用。这也被称为 /eager macro expansion/ ，这样做（而不是将宏展开推迟到运行时）可以大幅提高未编译代码的执行速度。有时由于循环依赖这样的宏展开不会进行，最简单的情况是 =load= 的文件中使用的宏在另一个文件中，而那个文件又依赖了被 =load= 的文件。一般来说这样是无害的，Emacs 会显示 /Eager macro-expansion skipped due to cycle…/ 的 Warning 并继续加载文件，并放弃宏展开。你可能会在之后重新编排你的代码来避免此事的发生。加载字节编译文件不会有这样的问题，因为宏展开已经在编译时发生过了。

当 =nomessage= 参数为 =nil= 时，加载开始时 echo area 会显示 "Loading foo..."，加载完成时会显示"Loading foo...done"。如果该参数为非 =nil= 就不会有这样的 message。对于 =eln= 文件也会有加载 message。

在加载时出现的任何未处理的错误都会中断加载过程。如果加载时通过 =autoload= 触发的，那么任意加载的函数都会回退。

 如果 =load= 不能找到需要加载的文件，那么他会引发 =file-error= 错误。但是如果 =missing-ok= 参数非 =nil= ，那么 =load= 只会返回 =nil= 。

我们可以使用变量 =load-read-function= 来指定用于替换 =read= 的读取函数。

如果加载成功， =load= 会返回 =t= 。
