#+SETUPFILE: ../../setup.org
#+FILETAGS: emacs js

#+TITLE: 在 emacs 里写 JS —— 对 JS 的简单介绍
#+DATE: [2022-10-19 Wed 15:28]

#+ATTR_HTML: :class top-down-img
[[https://twitter.com/CiloRanko/status/1401700442619351045][file:0.jpg]]

在简单介绍 JS 的 OOP 之前咱还是介绍下啥是 OOP 先，毕竟我没怎么写过面向对象的代码。你大可认为写这篇文章的时候我是个 OOP 白痴，然后跳过下一节中的大放厥词。我写这段的目的是给 *自己* 找一个说得过去的 OOP 认识。

如果你和我一样是从 C 开始学的编程，那么接触到的第一门所谓的 OOP 语言应该是 C++。很可惜的是我在学习 C++ 这件事上屡战屡败，到现在都没有看完 C++ Primer 第五版，我可是从二〇一九年就开始尝试了（笑）。不知道是不是学不会 C++ 这件事让我有点面向对象恐惧症，我现在还没有系统地学过任何的主流 OOP 语言，我的 Python 水平仅有读完官方 Tutorial 的水平，而且不会写类，我还尝试过 Java，但没写几行就放弃了。现在是看到 =class= 关键字我就不是很舒服，PTSD 了属于是。借着学习 emacs 和 javascript 的机会，看看这一次能否再次认识一下 OOP，让我摆脱掉 OOP PTSD。这一节我会参考一些资料，介绍一下 OOP 三要素（封装继承多态）出现之前的 OOP，看看最开始的 OOP 是什么样的。

和 JS 一样，我对 OOP 的认识约等于零，而且我也没有参加软件开发的经验，也就是说如果你在下文中发现了什么不对劲的地方的话，你很可能是对的。由于时间和能力问题，我不可能完成对整个 OO 范式发展的描述和分析，这大概够写一堆书的。OO 背后涉及到了很多计算机理论的知识，下文我会简单介绍一下粗浅的内容。原本我是准备在使用过市面上主流的 OOP 语言后再专门写一篇总结性的文章，但是实在太费事了，遂放弃，咱还是放弃整体求局部吧，一个足够简单的模型也许更易于认识，就像 λ 一样。在下文中我会使用 C++/CL/Elisp/Racket 作为基于类的 OO 代表，与 JS 作为基于原型的 OO 代表来举例。如果你不太了解 Lisp 系语言的话，C++ 代码应该比较容易懂。

最后声明一下，由于个人原因，我对于 OO 的态度并不怎么正面，所以下面内容整体可能对 OO 呈负面态度，当然我会尽量保证引用内容的准确性并给出来源。如果文中内容令你不快，可跳至下一节或 =Alt+F4= 或右划，或者给出你的观点。

{{{toc}}}

* OOP 简史

OOP 的全称是 Object Oriented Programming，即面向对象编程，也叫物件导向程式设计，强调将程序看作不同对象的调用交互过程。按我的理解，将程序看作对象的交互就是要在对象与对象之间划分出边界来，让每个对象负责好它自己的那一部分，这有点像社会中的人，只负责自己的吃喝拉撒。所以 *封装* 就是 OOP 的一大特点，作为对象的你把握好三寄吧原则就好：你寄吧谁啊，我寄吧谁啊，他寄吧谁啊。既然有了边界，那么两对象之间也需要交流机制，通过某种标准的方式来进行交互，这在 OOP 中被称为 *消息* 。 *封装* 与 *消息* 就是我对 OOP 的认识了，至于封装继承多态抽象啥的去他的吧。就这么看的话，咱写 OOP 的代码并不需要一门声称支持 OOP 的语言，下面我们用闭包来捏个计数器对象玩玩：

#+BEGIN_SRC javascript
    let Ytimer = function (init_value) {
	let val = init_value;
	this.get = function () { return val; };
	this.inc = function () { val = val + 1; return val; };
	this.dec = function () { val = val - 1; return val; };
    }

    let at = new Ytimer(10)

    at.get() // 10
    at.inc() // 11
    at.dec() // 10
#+END_SRC

上面的对象提供了三个方法，分别是获取计数，增加计数和减少计数，调用这些方法就像是发消息给这个对象，同时你也没有除 =get= 外的其他方法来获得当前计数器的值，这就非常的封装，非常的 OO。使用消息来达到完成某种动作的目的就意味着 *抽象* ，发号施令者把简单的消息告诉了实施者，再由实施者来完成，这也算是由少（消息）到多（动作）的过程，嗯，这很抽象。

我们上面拿函数来实现了消息机制，看上去比函数抽象也没高级到哪里去，这就要看和谁相比了：对 C 这种不允许匿名函数的语言来说，要想拿函数名字当作消息名有点困难，如果我们想给获取一堆对象的“长度”，那我们要给每个.


* 一般意义上的抽象

虽然在内容上与计算机网络没有太大的关系，这里还是顺带总结一下我对抽象的认识。觉得没意思的可以跳过。

一直以来我对抽象的认识就是“用更少的东西来表达更多的东西”，但显然这不太准确。在简单看过一些资料后，我认为想要认识抽象我们首先要从 *思维* 和 *语言* 开始。在开始之前我先推荐一本书《[[https://yueyao1982.com/reconstr_phil/index.html][哲学的重建]]》，对于像我这样的哲学白痴来说，这书算是不错的入门，我会在下文中时不时引用书中的内容。下面是我们将要涉及到的一些词的定义：

#+BEGIN_QUOTE
《现代汉语词典第 7 版》

抽象：
- 动词：“从许多事物中，舍弃个别的、非本质的属性，抽出共同的、本质的属性，叫抽象，是形成概念的必要手段”
- 形容词：“不能具体经验到的；笼统的；空洞的（与具体相对）”

概念：
- 名词：“思维的基本形式之一，反映了客观事物一般的、本质的特征。人类在认识过程中，把所感觉到的事物的共同特点抽出来，加以概括，就形成概念。比如从白雪、白马、白纸等事物里抽出它们的共同特点，就得出‘白’的概念”

语言
- 名词：“人类所特有的用来表达意思、交流思想的工具，是一种特殊的社会现象，由语音、词汇和语法构成一定的系统。‘语言’一般包括它的书面形式，但在与‘文字’并举时只指口语”

思维
- 名词：“在表象、概念等基础上进行分析、判断、推理等认识活动的过程。思维是人类特有的一种精神活动，是从社会实践中产生的”
#+END_QUOTE

根据《现代汉语词典第 7 版》的定义，抽象做动词时的意思是“从许多事物中，舍弃个别的、非本质的属性，抽出共同的、本质的属性，叫抽象，是形成概念的必要手段”，做形容词的意思是”不能具体经验到的；笼统的；空洞的（与具体相对）。这个定义中强调了要从 *许多* 事物中 *抽取* 出共同的本质属性，也就是说 *抽象* 这个 *动作* 与 *具体* 事物应该是一对多的关系。同时它还说到“抽象是形成概念的必要手段”。

| [[./3.png]] |

那么 *概念* 是个什么东西？它的定义是“思维的基本形式之一，反映了客观事物一般的、本质的特征。人类在认识过程中，把所感觉到的事物的共同特点抽出来，加以概括，就形成概念。比如从白雪、白马、白纸等事物里抽出它们的共同特点，就得出‘白’的概念”。需要注意的是这个定义中说的是从 *事物* 而不是 *词语* 中抽取得到的共同特点。我们感知到白雪，白马和白纸的颜色是白色，从中抽取了白色这个共同特点，而不是因为它们三个词中都有“白”这个字。

比较有意思的是，即使我们没有见过白马、白雪和白纸，我们也能从这三个词中找出共同的“白”字。词语和汉字就像是概念的一种 *编码* 一样，我们通过阅读将它们解码为脑中的概念，再开始对它们进行思考和抽象。也许这里我们有必要了解一下什么是 *思维* 和 *语言* 。 *语言* 的定义是“人类所特有的用来表达意思、交流思想的工具，是一种特殊的社会现象，由语音、词汇和语法构成一定的系统。‘语言’一般包括它的书面形式，但在与‘文字’并举时只指口语”。而 *思维* 的定义是“在 *表象* 、 *概念* 等基础上进行分析、判断、推理等认识活动的过程。思维是人类特有的一种精神活动，是从社会实践中产生的”。

某种意义上来说语言很像是思维的一种编码方式呢，将思维以语言表达就是序列化（serialization），而从语言中读取思维就是反序列化（deserialization）：

| [[./4.png]] |

不知不觉我们从最开始的 *抽象* 聊到了现在的 *思维* 和 *语言* ，这里让我们聊一聊这两者的关系。从文章开头看到现在你可能一直不知不觉在“默读”文中的句子，只不过看到这句话才意识到这件事（笑）。就别说阅读了，我们平时在想什么东西的时候也好像是脑子里面有一个声音在朗读我们所思所想。这样来看思维似乎需要语言才能进行？还是说语言是我们能感知到思维的一个操作界面（interface）？我比较认同后者，即语言是思维的 *一种* 表现形式。

至于语言对思维的影响，有人认为语言怎样描述世界我们就怎样观察世界，语言是认知的牢笼（似乎被否定了，这也叫做萨皮尔-沃尔夫强假说）；也有人认为语言知识对一些思维方式和日常行为产生一定程度的影响（弱假说）。关于这一点我的认识是：思维创造了语言，而语言又反过来影响了思维。这一块的知识我一无所知，还是看看专业点的解答吧：

#+BEGIN_QUOTE
思维和语言的关系是什么？ - 岳耀的回答 - 知乎

https://www.zhihu.com/question/27535310/answer/2192328532

1. [@1]在发生顺序意义上，语言是思维的产物，而思维绝不是语言的产物。但语言这个产物一旦产生，又成为了思维的一部分：这并不矛盾，因为思维是动态的。

很显然，一个刚出生的婴儿不会任何语言，但他已经具有了一定的思维。他运用思维去寻找食物（比如吸奶），寻找乐趣（比如玩玩具）：虽然在这些过程中，婴儿不仅运用思维也运用本能，但随着小孩的成长，思维所占的比重越来越大。他从外部接收信息并对这些信息进行处理，而他之所以能学会语言，正是外部语言刺激和内部数据处理的共同结果。而“内部数据处理”，事实上是就思维的一种表现。

2. [@2]语言构建过程本身就是一个思维过程。

纯粹的背诵不构成语言：语言构建事实上是语言中最重要的要素之一。人们通过语言构建去表达他们想要表达的想法。而语言构建本身就是一个思维过程。在初等教育中，这种构建能力在语文教育中的组词、造句、作文等形式中得到训练。

引导我们进行语言构建的更高层次的思维方法是“否定”和“逻辑”。从最浅显的层面来说，基本所有语言都有表示因果、转折、否定、承接的连词和副词。这两种思维方法在越宏观的层面体现得就越明显。在组词的阶段，它们基本不显现；在简单句的阶段，它们偶尔显现；在复合句的阶段，它们开始变得重要；在文章的层面，它们就更为重要了。

3. [@3]语言对思维提升具有重大作用

虽然语言是思维的产物，但语言一经产生，就被整合在思维中了。有了语言，我们不仅可以有效地与他人交流，我们自己的思维也得到了提升。这是因为，作为一种由思维本身产生的系统，语言本身符合思维的要求（否则就不是准稳态：思维会进一步引导它快速达到准稳态）。有了语言，概念就可以被简明地表达（就像编程语言中的指针一样），简明地操作（比如组合），产生的更高层概念也同样可以被简明地表达（被“封装”在一个词中，或者说被一个容易激发类似思维图景的词所指向）。这种产生更高层次概念的能力，在语言的辅助下，是没有界限的。一个没有语言功能的人就像一台没有装上操作系统的裸机，虽然在理论上具有所有思维能力，但这些思维能力难以被有效地使用。有了语言，思维这台“计算机”就像被装上了操作系统、开发软件、应用程序等等，极大地提高了思维的效率和层次。

有了文字之后，特别是有了录音录像设备之后，语言就有可以被长久地记录：这对于人们既不保证可靠、也不保证准确的记忆是极大地辅助（除此之外，辅助人记忆的还有使用结绳记事、算筹等方法）。在我们可以记录语言之前，这使得我们可以反复地研究概念，研究理论，以至研究语言本身。

4. [@4]我们可以设计“完美语言”去获得“完美思维”吗？

语言是思维这座冰山在海面上易被看见的部分，是不断运动的思维所结出的晶体。好的语言，可以帮助人的提升思维。使用不同语言的人，在思维上可能会有不同之处。这是因为，各种语言之间一般来说并没有一一对应的关系。如果一个概念在 A 语言中对应一个很常见的词，在 B 语言中却缺失，那么虽然使用 B 语言的人当然也可以产生这个概念，但在使用 A 语言的人那里，这个概念不仅会被“强制产生”（即使不自发产生，也几乎必然被词语诱导产生），而且被经常使用。因此，使用 A 语言的人从总体来说，应该比使用 B 语言的人更熟悉这个概念。从另一个角度来说，如果不是这样，那个词大概不会是 A 语言中的常用词；即使以前是，也早就退出常用词的行列。从这个角度来说，使用不同语言的人，在思维上会有不同之处，多学几门外语也有助于拓展思维（当然需要学到一定程度）。

*为了满足人的各种要求，非自然语言也被开发出来，比如形式语言、编程语言等等。然而，它们的一些优秀特性也引发了一些人的“盲目崇拜”，好像如果有一天我们可以开发并运用一门完全精确的语言，那么所有的问题都会被解决似的。在我看来，这是一种极其错误的看法，甚至是一种对自己的思维极度不负责任的看法。有了这个“法宝”，人们就可以把自己产生的思维错误归咎到语言的不完美上去，而语言看起来一时半会儿也不会被“完美化”，所以他们就有了“万能借口”。然而，那个“完美语言”，事实上是现有语言的子集：它不可能包含任何超出所有自然语言的东西，也必须剔除他们认为自然语言中“不好”的东西。这就意味着，他们设想的那些没有矛盾的东西，在自然语言中必然是可以表达的，即使在自然语言中表达不方便，我们也有各种各样的形式语言、数学语言等。因此，真正重要的问题是训练自己的思维，而不是坐等一门“完美语言”的诞生。事实上，一门语言即使在形式上完美，也并不能保证使用它的人不犯语法错误，因此思维错误归根结底仍然是思维的问题，即使一门好的语言在某些情况下可以避免这种情况的发生。况且，“完美”只是某种意义上的完美。为了保证在精确性上的完美，语言的表现空间就会被大大压缩，那里可能不再有诗词歌赋，不再有象征隐喻，所以它真的“完美”吗？*

更需要注意的是，虽然从表面上来看，语言和思维都是运动的。然而，思维的运动是自发的（虽然具体会往哪里运动我们可能并不清楚），而语言的运动是被思维运动所推动的，或者毋宁说语言的运动就是思维运动的外在表现。如果没有思维的运动，单单把语言拿出来，它是不会运动的，也不会产生任何新结果。
#+END_QUOTE

这篇回答我接近全文引用了，这可能是我认为作者写的非常有道理。作者写了一本叫做的书，感兴趣的可以去看看。特别是[[https://www.yueyao1982.com/reconstr_phil/abstraction.html][抽象化、具象化与抽象建构]]一章。

我们从 *抽象* 开始了解了 *概念* ，然后是 *思维* 和 *语言* 。这似乎偏离了单纯介绍什么是抽象的目的，但不了解这些相关概念我们也无从对抽象有一个足够好的认识。让我们简单做个总结吧：抽象是这样一种思维过程，它从许多事物中抽取出共同的本质属性来得到概念。

还有一些很重要的东西要讲，比如我们如何得到抽象、抽象的层次、由抽象构建抽象、抽象的具象化等等。由于我在这方面知识的匮乏，请参考上面给出的[[https://www.yueyao1982.com/index.html][岳耀]]的书来进一步了解。这里我也稍微引用一点：

抽象的种类：

#+BEGIN_QUOTE
第一类抽象：以感官对象为基础的抽象。

这类抽象以很多感官对象为基础，抽象出抽象概念，比如我们从很多具体的苹果抽象出“苹果”这个概念。

第二类抽象：以概念为基础的抽象

这类抽象以概念为基础，抽象出更为抽象的概念。 比如我们以具体的数为基础，抽象出数集。 这种抽象化与第一种抽象化有本质的区别：具有最终决断权的是意识，而不再是意识的下属部门。 这是因为，以概念为基础产生概念的过程，是意识自身的行为，虽然在这个过程中，意识的下属部门也在起作用，比如从记忆中调取数据传达给意识。

在这里，我们首先需要注意一点。 我们说以概念为基础产生的概念，其内涵是由意识决定的：这里的“内涵”只包含这个概念的直接下属概念，而不包含这些下属概念的所有具象化对象。 比如，我们可以明确地定义“家具”，比如把所有家具的类别都列举出来，比如{桌子、椅子、立柜、沙发……}。 如果这是一个有限的集合，我们就说这个家具的定义是清楚的。 然而，这个定义却只涉及组成家具的各个元素概念，去不直接涉及各个元素概念本身是什么：比如它并不规定一个经验世界中的物体是否会被对象化成一个桌子， 比如一个经常被我们用作桌子功能的宽阔窗台究竟是不是桌子。

方法1：以规定内涵的方法来进行抽象

在使用内涵的方法进行抽象时，我们定义这个更高层次的抽象对象所包括的抽象对象应该具有的性质。 比如“动物”这个概念就是以概念为基础抽象出的概念。使用内涵的方法进行抽象，人就需要更高的思维能力，因为内涵之间可能是互相矛盾的。 比如罗索悖论的产生原因，就是定义集合的内涵，是有潜在矛盾的。一个抽象概念产生之后，我们经常会对其进行调整。概念的外延经常会被调整，而这经常是我们对概念的内涵调整的结果。

方法2：以规定外延的方法来进行抽象

在使用外延的方法进行抽象化时，我们把所有属于这个概念的对象进行列举，比如“家具=∪{桌子、椅子、立柜、沙发……}”， “生物=∪{动物，植物，细菌，真菌，原生生物，古菌，病毒，亚病毒因子，……}”，“自然数={1，2，3，4，……}”，“电荷={正电荷、负电荷}”。 使用这种方式，我们可以明确地定义一个高等级的抽象概念：一个元素属不属于这个集合，我们只要去查这个列表就可以了。

为了与内涵法相一致，外延法在对集合对象进行抽象时，我们要取其并集(∪)，即从形式上来说是把所有的集合中的元素都取出来后再组合在一起进行对象化（虽然我们在抽象化的过程中并不显式地那样做），而不是简单地把集合直接组合起来并进行对象化。否则的话，我们要确定两个概念的关系，经常需要很多额外的抽象层次。

需要注意的是，我们在使用外延的方法定义一个抽象概念时，重要的不仅仅是列举，也是对列举的整体对象化：这在自然语言中表现为赋予这个整体对象化一个名字。 在意识中，实际上我们在把这个列举看成一个整体时，抽象化已经完成了：它不必有一个语言上的名字。
#+END_QUOTE

抽象的层次：

#+BEGIN_QUOTE
我们在完成抽象化后，就可以使用我们得到的抽象概念来进行进一步的抽象化。 这样我们就得到了不同抽象层次的概念，比如抽象层次依次提高的家猫、猫属、食肉目、哺乳动物、羊膜动物、脊椎动物、后口动物、动物。 抽象层次越高，则包括的“象”就越少。 比如我们在谈论一只具体的猫时，可以谈论它的花色和毛长等特征； 我们在谈论“家猫”这个概念时，头脑里大概只有一个猫的轮廓，而不包括花色和毛长那些具体特征了； 我们在谈论“哺乳动物”这个概念时，会大概有一个“有头、躯干和四肢，经常有毛发”的意象，虽然事实上也存在海豚和鲸这些与这种意象非常不符的哺乳动物； 我们在谈论“动物”时，则很难产生任何包含很多细节的意象（假设我们已经见过很多不同种类的动物）。
#+END_QUOTE

由抽象构建抽象：

#+BEGIN_QUOTE
抽象建构用抽象对象为材料，建构更复杂的抽象对象：这是组合倾向的结果。 与抽象化不同，抽象建构生成的抽象对象，与那些作为原材料的抽象对象，具有同样的抽象等级。 比如一个三角形是由三个点和三条边按一定规则组合而成的，笛卡尔说的千边形也是用类似的方法组合而成的。 一个三角形不比组成它的点和边更抽象，因为它们之间是部分与整体的关系而不是集合上的属于关系。 之所以如此，是因为我们在构建三角形时，使用的是具体的点和边，而不是点和边的概念本身。 抽象的过程则相反：我们在用外延的方法从不同种类的动物抽象出”动物“这个更抽象的概念时， 我们用的是”猫“和”狗“等概念，而不是一些具体的猫和狗（虽然我们用并集法定义“动物”时隐式地涉及到了所有具体的对象）。 虽然正如笛卡尔指出的那样，我们可以很轻易地精确想象一个三角形，却很难精确想象一个千边形，但那是直观的限制，与抽象等级无关。
#+END_QUOTE

抽象的具象化：

#+BEGIN_QUOTE
一个抽象概念在产生之后，我们不仅可以用它进行进一步的抽象化或者用它和其他概念进行比较，还可以用它指代经验世界中的对象或抽象级别更低的概念。 比如，“动物”这个概念可以指代“猫”这个概念，也可以指代一只感官世界中的猫。 在这个过程中，在抽象化过程中“被抽掉的象”又被根据具体的情境添加了回来，因此我们把它称为具象化。 具象化的一种特殊情况是实体化，即从抽象概念直接具象化为经验世界中的对象。

具象化，是抽象化的逆过程。 它最基本的形式（不考虑抽象建构的情况）在抽象化发生的时候，已经被隐含地定义了。 在抽象化的过程中，我们“抽”掉了具体的“象”，即原材料对象之间彼此不同的杂多特征，来得到了抽象概念。 因此，一个抽象概念就天然地可以指代那些原材料或与那些原材料相似的对象（泛化倾向的体现）。 一旦我们使用了这种指代，具象化就产生了：所指对象特有的杂多特征又被添加回来了。

以上讨论的是纯粹由抽象化产生的抽象概念。如果我们在概念的产生中，使用了抽象建构，则产生的概念在自然条件下可能难以被实体化。 为了实体化它们，我们可能需要人工生产。 比如我们用“马”和“翅膀”这两个概念构造出了“天马”（这里的讨论是对概念建构者而言的，而不是对已经看到实体化天马的儿童而言的）。
#+END_QUOTE

* 编程中的抽象手段

这是我相对熟悉的一部分，没必要使用那么多引用了。在编程中我们几乎无时不刻不和抽象打交道，这大概也是为什么我想要认识抽象的原因。让我们从两个方面来认识编程中的抽象，一是各种编程语言中为我们提供的概念，也就是帮我们做的抽象；二是我们如何通过编程语言来创建概念，也就是使用编程语言提供的概念来构建抽象对象。前者对应于学习一门编程语言的基本知识，后者对应于使用这门语言来编写程序。

就像自然语言中的概念是事物经思维抽象后的产物，程序语言中的概念自然也是计算机中的事物的抽象产物。程序语言是用来定义计算机语言的形式语言，它们相比于自然语言缩减了词汇，降低了容错性，增强了严谨性和无歧义性。编程语言在表达能力上远弱于自然语言，但以此为代价换取了更好的专用能力，即表达程序的能力。下面我们来了解一些比较通用的程序语言概念。

- 变量（variable）。变量是对存储的抽象，表示一个可变的（当然也可不可变）存储。绝大多数语言中都有这个概念
- 数组（array）。数组是对连续定长存储的抽象（没想到吧这也算抽象）
- 指针（pointer）。指针是对存储的地址的抽象。可以用来索引存储中的某一位置
- 类型（type）。类型是对具体值的抽象，表示值的范围的集合。比如 C 语言中有 =int= ， =char= ， =float= ， =double= 等基础类型。当你使用 =char= 类型的变量时，就表示你正在使用一个范围为 -128~127 的整数值
  - （在不同的语言中类型可能有动静强弱之分，但在这里并不重要）
- 条件与循环（conditional and loop）。两者都是对 /有条件跳转/ 的抽象（不要觉得这是理所当然的）
- 函数或过程（function，procedure）。函数是对一段代码的抽象，通过调用它可以完成某种任务或实现某个功能
  - （对过程式编程来说，函数是程序的基本组成部分）
- 对象（object）。是对包含数据和代码的东西的抽象。对象是面向对象编程中程序的基本组成部分

如果你学过简单的 C 语言，你应该对上面的概念很熟悉，甚至感觉不到它们是经过抽象后的产物。如果我们使用的是近年来（指 1970 年后（笑））发明的高级语言那自然感觉不出这些概念有什么特别的。但一旦我们使用了缺失这些概念的编程语言，我们就立刻能体会到它们的可贵之处，下面是一段 C 代码和一段汇编代码，它们都实现了计算斐波那契数列的功能，但代码的长度和可读性可谓天上地下：

#+BEGIN_SRC c
  int fib (unsigned int n)
  {
      if (n == 0) {
	  return 0;
      } else if (n == 1) {
	  return 1;
      } else {
	  return fib(n-1) + fib(n-2);
      }
  }
#+END_SRC

#+BEGIN_SRC asm
	  ;; https://gist.github.com/emberian/3894436
	  ;; Midterm Programming Question 3
	  ;; fibonacci.asm
	  ;; (nasm syntax)
	  ;; Corey Richardson
	  ;; CS310
	  ;;
	  ;; Use a loop to calculate and print the first 7 fibonacci numbers

	  global _start ; make sure the linker can see entry point
	  %include "Along32.inc" ; linux/nasm equivalent of Irvine32

	  section .text
	  ;; function fib
	  ;; takes one parameter: ecx -- return the ecx'th fibonacci number
	  ;; returns the value in eax
  fib:
	  cmp ecx, 2 ; special-case fib(1) and fib(2)

	  ja .body ; for fib(>= 3)
	  mov eax, 1
	  jne .done ; fib(1) and fib(0) are 1
	  mov eax, 2
	  jmp .done

	  .body:
	  push ebx ; keep things clean for the caller
	  push ecx
	  ;; use an iterative algorithm, rather than a recursive one
	  ;; (picked up this trick from SICP)

	  sub ecx, 2 ; already handled fib(1) and fib(2), don't do extra loops
	  mov ebx, 1 ; ebx = fib(n-2)
	  mov eax, 2 ; eax = fib(n-1)

	  .loop:
	  xchg eax, ebx
	  add eax, ebx
	  loop .loop

	  ;; eax is all set and ready to go
	  pop ecx ; clean up registers
	  pop ebx
	  .done:
	  ret

  _start:
	  mov ecx, 7 + 1 ; set it to one more than the desired number of iterations

	  .loop:
	  mov ebx, ecx ; save the loop counter in ebx
	  mov ecx, 8
	  sub ecx, ebx ; subtract the previous loop value from 8
	  ;; since we start at 8, the fib argument goes 0, 1, 2, 3, ...
	  call fib
	  call DumpRegs
	  mov ecx, ebx ; put the loop counter back so it will be decremented
	  loop .loop

	  mov eax, 1 ; exit syscall
	  mov ebx, 0
	  int 0x80
#+END_SRC

如果汇编还无法说服你的话，这里还有一段 brainfuck 的 hello world。brainfuck 是一种古怪的语言，它只有 8 个操作符却实现了图灵完备，极简的语法也意味着它没有提供一些非常常见的概念：

#+BEGIN_SRC text
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
#+END_SRC

哈哈，有没有一种断手断脚的感觉。编程语言相比于自然语言更强调逻辑而不是直觉，比起自然语言中的“语言会对思维产生影响”，我更倾向于认为“程序语言决定了编写程序时的思维”。像 brainfuck 这样的语言真可以说是“语言的牢笼”了，你的整个思维都被它的 8 个操作符限制了。好的编程语言是有助于我们的思考的，某些体现语言特点的独有概念也被叫做语言特性。

下面让我们聊一聊使用程序语言来构建抽象。我们没法用一门语言表达出超出语言表达能力的事物，但在这个范围内就已经够我们用了。在提供概念的同时，编程语言也允许我们使用这些概念构建得出新的概念。比如这个 =add= 函数：

#+BEGIN_SRC c
  int add (int a, int b)
  {
      return a + b;
  }
#+END_SRC

相比函数它更加具体，但相比于具体的执行过程它仍是抽象的。我们使用函数和其他的一些概念构建出了 =add= 这个新的概念。从面向对象的角度来说 =add= 函数就是函数类的一个实例。在 C 语言中我们可以使用 =typedef= 创造新的类型，比如这个鬼畜的类型定义： =typedef int (*apf[])();= 。使用类型和变量我们可以声明出具有某类型的变量，比如 =apf a= 。凡是语言允许的东西我们都能构建出来。编程与写作的差别也许并不是那么大。

等等，抽象的作用不是
（聊一聊通常意义上的抽象）面向语言编程 EOPL
没有银弹
抽象是否一定意味着封装。
